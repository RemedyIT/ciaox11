/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#include "hello2_cc_svnt.h"

// generated from corba4ccm/templates/corba/pre_extra_include
#include "ciaox11/deployment/util/ciaox11_corba_util.h"
// generated from exf4cc/templates/svnt/src/corba/exf/corba/exf/pre_extra_include
#include "exf/deployment/core/ciaox11_schedule.h"

// generated from ccmx11/templates/svnt/src/corba/exf/component
namespace Hello_B_SRR_CORBA_Connector_Impl
{

  CORBA_Connector_ExecutorLocator::CORBA_Connector_ExecutorLocator (
      IDL::traits< ::Hello_B_SRR::CCM_CORBA_Connector>::ref_type component_executor,
      IDL::traits<CORBA_Connector_Context>::ref_type component_context) :
        component_executor_ (std::move (component_executor)),
        component_context_ (std::move (component_context))
  {
  }

  bool
  CORBA_Connector_ExecutorLocator::connect (
      const ::Components::FeatureName& name,
      IDL::traits<CORBA::Object>::ref_type connection,
      const std::string& conn_name,
      const ::Components::ConfigValues& config)
  {
    // generated from exf4cc/templates/svnt/src/corba/exf/corba/component_init_connect

    // prefer remote/colocated reference connection; use local exec ref only when necessary
    IDL::traits<CORBA::Object>::ref_type objref =
        CIAOX11::Corba::Utility::get_provider_reference (config);
    if (objref)
    {
      connection = std::move(objref);
    }
    else if (!connection)
    {
      return false;
    }

    // generated from exf4cc/templates/svnt/src/corba/exf/component_connect
    X11_UNUSED_ARG(conn_name);
    return this->component_context_->set_connection (name,
                                                     std::move(connection),
                                                     config);
  }

  bool
  CORBA_Connector_ExecutorLocator::disconnect (
      const ::Components::FeatureName& name,
      const std::string& conn_name)
  {
    X11_UNUSED_ARG(conn_name);
    return this->component_context_->reset_connection (name);
  }

  void
  CORBA_Connector_ExecutorLocator::configure (
      ::Components::ConfigValues& config)
  {
    X11_UNUSED_ARG (config);
    // generated from exf4cc/templates/svnt/src/corba/exf/component_configure
    // Mark connector as having no scheduling lane itself
    bool flag { true };
    CORBA::Any val;
    val <<= flag;
    config.push_back (Components::ConfigValue (CIAOX11::ExF::NO_SCHEDULING_LANE, val));
  }

  IDL::traits<CORBA::Object>::ref_type
  CORBA_Connector_ExecutorLocator::obtain_executor ()
  {
    return this->component_executor_;
  }


  // generated from ccmx11/templates/svnt/src/corba/exf/component_obtain_facet_executor
  IDL::traits<CORBA::Object>::ref_type
  CORBA_Connector_ExecutorLocator::obtain_facet_executor (
    const ::Components::FeatureName& name,
    ::Components::ConfigValues& /*config*/)
  {
    if (name == "srr_facet")
    {
      return this->component_executor_->get_srr_facet ();
    }
    // no match
    throw CIAOX11::InvalidName (name);
  }

  CORBA_Connector_Context::CORBA_Connector_Context (
      IDL::traits<CIAOX11::Service_Registry>::ref_type svcreg,
      std::string ins_name) :
        service_registry_ (std::move (svcreg)),
        instance_id_ (std::move (ins_name))
  {
  }

  IDL::traits< ::CIAOX11::Service_Registry>::ref_type
  CORBA_Connector_Context::the_service_registry ()
  {
    return this->service_registry_;
  }

  IDL::traits<Hello::B>::ref_type
  CORBA_Connector_Context::get_connection_srr_receptacle ()
  {
    return this->srr_receptacle_;
  }
  // generated from exf4cc/templates/svnt/src/corba/exf/connector_context_extra_receptacles
  ::Components::ConfigValues
  CORBA_Connector_Context::srr_receptacle_configuration ()
  {
    return this->srr_receptacle_config_;
  }


  // generated from exf4cc/templates/svnt/src/corba/exf/context_set_connection
  bool
  CORBA_Connector_Context::set_connection (
    const std::string& name,
    IDL::traits<CORBA::Object>::ref_type connection,
    const ::Components::ConfigValues& config)
  {
    if (name == "srr_receptacle")
    {
      this->srr_receptacle_ = IDL::traits<Hello::B>::narrow (std::move(connection));
      // copy all (applicable) configuration values for this connection
      this->srr_receptacle_config_ = config;
    }
    else
    {
      return false;
    }
    return true;
  }


  // generated from exf4cc/templates/svnt/src/corba/exf/context_reset_connection
  bool
  CORBA_Connector_Context::reset_connection (
    const std::string& name)
  {
    if (name == "srr_receptacle")
    {
      this->srr_receptacle_ = nullptr;
      // Clear configuration values for this connection
      this->srr_receptacle_config_.clear ();
    }
    else
    {
      return false;
    }
    return true;
  }

  std::string
  CORBA_Connector_Context::instance_id ()
  {
    return this->instance_id_;
  }
} /* Hello_B_SRR_CORBA_Connector_Impl */

extern "C" void
create_Hello_B_SRR_CORBA_Connector_Servant (
  IDL::traits<Components::EnterpriseComponent>::ref_type p,
  IDL::traits<CIAOX11::Service_Registry>::ref_type svcreg,
  const std::string& ins_name,
  IDL::traits<CIAOX11::ExecutorLocator>::ref_type& executor_locator)
{
  IDL::traits< ::Hello_B_SRR::CCM_CORBA_Connector>::ref_type component_executor =
    IDL::traits< ::Hello_B_SRR::CCM_CORBA_Connector>::narrow (std::move(p));

  if (component_executor)
  {
    // Create the context for this component, passing in it's ServiceRegistry
    IDL::traits<Hello_B_SRR_CORBA_Connector_Impl::CORBA_Connector_Context>::ref_type context =
      CORBA::make_reference<Hello_B_SRR_CORBA_Connector_Impl::CORBA_Connector_Context> (std::move(svcreg), ins_name);

    // Set the new context onto the user component executor
    component_executor->set_session_context (context);

    // Create the executor locator which holds the references
    // to all created entities
    executor_locator =
      CORBA::make_reference <Hello_B_SRR_CORBA_Connector_Impl::CORBA_Connector_ExecutorLocator> (
        std::move (component_executor),
        std::move (context));
  }
}

// -*- END -*-
