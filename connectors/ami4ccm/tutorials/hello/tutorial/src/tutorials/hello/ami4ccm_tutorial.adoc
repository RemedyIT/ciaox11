include::_{backend}_settings.adoc[]

= AMI4CCM Hello Tutorial

== Introduction

This tutorial explains how to use Asynchronous Method Invocation for CCM
(AMI4CCM). AMI4CCM provides user components the ability to issue an
asynchronous invocation which doesn't block the user component until the
request has been executed. Optionally AMI4CCM provides the functionality
to receive a callback at the moment a request has been executed
(successfully or not). The AMI4CCM Connector component realizes the
asynchronous invocation using CORBA AMI. See the OMG https://www.omg.org/spec/AMI4CCM[AMI4CCM]
specification for more information about the specification itself.

=== System overview

This tutorial consists out of four components:

* Sender component
* Receiver component
* AMI4CCM connector
* <<{xref_docs_root}/corba4ccm/corba4ccm.adoc#,CORBA4CCM connector>>

In this tutorial a Sender invokes methods on the Receiver
asynchronously and synchronously. Therefor the Receiver
is deployed collocated with a CORBA4CCM connector and the Sender is
deployed collocated with a AMI4CCM connector. The AMI4CCM connector delivers
the support to
asynchronously and synchronously invoke methods (see schema below).
The AMI4CCM connector is completely
generated by the *AXCIOMA* RIDL compiler and it's implementation will
handle all details of executing the asynchronous invocation and callback
to the user component at the moment the request has been completed. The
Receiver (Server side) isn't aware of any AMI4CCM and uses a
CORBA4CCM connector.

.AMI4CCM connection scheme
image:{images_root}/ami4ccm/synconn.png[image]
_Yellow connections are local; green connections are remote CORBA._

There are different methods used in this example in order to show
different aspects:

* method with return value, in- and out argument:

[source,idl]
-----------------------------------------------
long foo (in string in_str, out string answer);
-----------------------------------------------

* void method with out argument:

[source,idl]
-----------------------------
void hello (out long answer);
-----------------------------

* method to set and get an attribute:

[source,idl]
--------------------------------
attribute short rw_attrib getraises(InternalError) setraises (InternalError);
--------------------------------

* method to get an readonly attribute:

[source,idl]
----------------------------------------------------------
readonly attribute short ro_attrib raises (InternalError);
----------------------------------------------------------

=== Directory structure

The following convention is used:

[source]
-------------------
./*_asm      : Directory contains a project
  /ports     : Directory contains common IDL code for the project
  /*_comp    : Directory contains a component
    /ports   : Directory contains common IDL code for the component and AMI4CCM connector
    /src     : Directory contains the IDL and *_exec-files for the component
-------------------

==== File naming convention

The following convention is used to name the IDL files:

[cols="<m,<5",options="header",]
|=========================================
|File name |Content description
| *_obj.idl* | These files will contain interfaces between components and definitions, like enumerations, constants and so on. Typically located in *_asm/ports.
| *_comp.idl* | These files will contain the component declaration. Typically located in *_asm/*_comp/src.
|=========================================

==== Additional conventions

* MPC files are located in the same directory as the IDL and executor
files. There's one additional MPC file in the *_asm/ports directory, called
**_cc.mpc*. This MPC contains the logic to completely generate and
compile the CORBA4CCM connector.
* Files that are generated by the RIDL compiler are located in the `generated_code`
subdirectory, except the component executor starter code.

== IDL

IDL files are created by a designer or generated by a modeling tool. To
understand this example we will give an overview of which IDL files are
normally generated.

=== Common IDL files

Below a simplified representation of the common IDL files. Use the links
to view the file itself. The following IDL file can be found in
hello_asm/ports:

* link:{docs_root}/../../ciaox11/connectors/ami4ccm/tutorials/hello/hello_asm/ports/hello.idl[hello.idl] :  +
Contains common includes and defines IDL interfaces. This IDL
also contains the #pragma's for enabling AMI4CCM, needed by the RIDL
compiler:
** Pragma needed for each interface for enabling support for AMI4CCM. +
+
`#pragma ami4ccm interface "Hello::MyFoo_obj"`
** Name of the implied IDL file, used by RIDL compiler to generate the
AMI4CCM functionality: +
+
`#pragma ami4ccm idl "helloA.idl"`

This IDL contains the interface MyFoo_obj which is used between the Sender and Receiver component

[source,idl]
-----------------------------------------------
interface MyFoo_obj
{
  long foo (in string in_str,out string answer)
    raises (InternalError);

  void hello (out long answer)
    raises (InternalError);

  attribute short rw_attrib
    getraises (InternalError)
    setraises (InternalError);

  readonly attribute shortro_attrib
    raises (InternalError);
};
-----------------------------------------------

=== Component IDL files

==== Sender component

The
link:{docs_root}/../../ciaox11/connectors/ami4ccm/tutorials/hello/hello_asm/sender_comp/src/hello_sender_comp.idl[hello_sender_comp.idl]
file in the sender_comp/src directory defines the Sender component that
wants to _use_ the asynchronous and synchronous connections.
For synchronous invocations, the Sender component uses the MyFoo_obj
interface (which the AMI4CCM connector also provides):

[source,idl]
-------------------------------
component Sender{
  /// For synchronous invocation
  uses MyFoo run_my_foo;
};
-------------------------------

For asynchronous invocations, the Sender component uses the
AMI4CCM_MyFoo_obj interface of the AMI4CCM connector and provides the
AMI4CCM_MyFoo_objReplyHandler interface to the AMI4CCM connector. +
This is indicated with the following pragma: +

`#pragma ami4ccm receptacle "Hello::Sender_comp::run_my_foo"`

==== Receiver component

The
link:{docs_root}/../../ciaox11/connectors/ami4ccm/tutorials/hello/hello_asm/receiver_comp/src/hello_receiver_comp.idl[hello_receiver_comp.idl]
file in the receiver_comp/src directory defines the Receiver component
which provides a port that is used by the Sender component.

[source,idl]
-------------------------------------------
component Receiver
{
  /// Provide a receptacle of type MyFoo_obj
  provides MyFoo_obj do_my_foo;
};
-------------------------------------------

The receiver isn't aware whether the calls that are invoked by the sender are
made asynchronous or synchronous.

== Executors

Once the IDL files are created, the business logic for the components
should be implemented. Since components can be large and complex, we can
use the RIDL compiler to create starter executor files (without export-
includes and macros). This part of the tutorial explains how this can be
done.

=== Sender component

In a command shell windows, navigate to the hello_asm/sender_comp/src
and invoke the RIDL compiler by running the following command:

-----
$X11_BASE_ROOT/bin/ridlc -I../../ports -I$CIAOX11_ROOT -I$CIAOX11_ROOT/ccm -Gex  --no-stubs --no-skel hello_sender_comp.idl
-----

An example of the generated code can be found
link:{code_root}/ami4ccm/generated_exec/hello_sender_comp_exec.cpp[here]. An example of
the implemented executor can be found
link:{code_root}/ami4ccm/implemented_exec/hello_sender_comp_exec.cpp[here]. +
Be aware that this command will not overwrite the already implemented
exec code in the hello_asm/sender_comp directory, but regenerates the
file and keeps the existing code that is between the regeneration
markers.

=== Receiver component

Navigate to the hello_asm/receiver_comp/src and invoke the RIDL compiler
by running the following command:

-----
$X11_BASE_ROOT/bin/ridlc -I../../ports -I$CIAOX11_ROOT -I$CIAOX11_ROOT/ccm -Gex --no-stubs --no-skel hello_receiver_comp.idl
-----

An example of the generated code can be found
link:{code_root}/ami4ccm/generated_exec/hello_receiver_comp_exec.cpp[here]. An example
of the implemented executor can be found
link:{code_root}/ami4ccm/implemented_exec/hello_receiver_comp_exec.cpp[here]. +
Be aware that this command will not overwrite the already implemented
exec code in the hello_asm/receiver_comp directory, but regenerates the
file and keeps the existing code that is between the regeneration
markers.


== AMI4CCM Concepts

=== AMI4CCM connector implementation

==== AMI4CCM basics

The developer basically has to write three IDL files

[cols="<m,<5",options="header",]
|=========================================
|File name |Content description
| *hello.idl* | The common definitions and interfaces between the Sender and Receiver
| *hello_sender_comp.idl* | The component definition for the Sender
| *hello_receiver_comp.idl* | The component definition for the Receiver
|=========================================

Naturally, it is possible that there are more IDL-files to be used. For
example you can choose to have a separate IDL file for the common
definitions.

The Receiver component ('server') has no idea which connector (AMI4CCM
or CORBA4CCM) uses his interface on the client side.

The AMI4CCM Connector will be generated by the RIDL compiler by
implying ami4ccm.idl

The CORBA4CCM Connector will be generated by the RIDL compiler (MPC).

In the Sender executor the handling of the AMI4CCM callbacks and the
asynchronous and synchronous invocations must be implemented.

==== Example

The Sender component of this Hello tutorial invokes some asynchronous
methods and some synchronous methods. For asynchronous invocations, the
Sender component uses the `AMI4CCM_MyFoo_obj` interface of the AMI4CCM
connector and provides the `AMI4CCM_MyFoo_objReplyHandler` interface to
the AMI4CCM connector.

For synchronous invocations, the Sender component uses the `MyFoo_obj`
interface, which the Receiver provides. There is always a
CORBA4CCM connector deployed on the receiver side, which is connected to the
Receiver component. +
There are now two possibilities how to create the connection between
the Sender component and the CORBA4CCM connector of the Receiver component.

.  The Sender component connects to the synchronous port on the AMI4CCM
connector which in turn is connected to the CORBA4CCM connector of the
Receiver.
.  A second CORBA4CCM connector is deployed on the sender side. The Sender
component connects to this CORBA4CCM connector which in turn is connected to
the CORBA4CCM connector of the Receiver.

The receiver implements the interface provided by the application
programmer. The Receiver has no idea which of the above mentioned
"connection chains" is used.

*Sender_comp_exec.cpp*

In de ccm_activate method, activate two worker threads and retrieve the
receptacles:

.Asynchronous receptacle
[source,c++]
------------------------------------------------------------------
 IDL::traits<::Hello::AMI4CCM_MyFoo_obj>::ref_type my_foo_ami_ =
   this->context_->get_connection_sendc_run_my_foo();
------------------------------------------------------------------

.Synchronous receptacle
[source,c++]
--------------------------------------------------
IDL::traits<Hello::MyFoo_obj>::ref_type my_foo_ =
   this->context_->get_connection_run_my_foo ();
--------------------------------------------------

After retrieving the receptacles, make the desired asynchronous and
synchronous invocations.
The asynchronous methods have the prefix `sendc_`. The first argument is
a reference to the Reply handler.

.Asynchronous invocation
[source,c++]
-----------------------------------------------------------------------
IDL::traits<::Hello::AMI4CCM_MyFoo_objReplyHandler>::ref_type cb =
  CORBA::make_reference<AMI4CCM_MyFoo_objReplyHandler_run_my_foo_i> ();

my_foo_ami_->sendc_foo (cb, "Do something asynchronous");
-----------------------------------------------------------------------

The same with synchronous method:

.Synchronous invocation
[source,c++]
-----------------------------------------------------------------------
int32_t result = my_foo_ami_->foo("Do something synchronous", out_str);
-----------------------------------------------------------------------

For the asynchronous methods the implied Reply Handler interface must
have an implementation for each method.

.Example foo callback
[source,c++]
-----------------------------------------------------------------------------------------------------------------------
void
AMI4CCM_MyFoo_objReplyHandler_run_my_foo_i::foo (int32_t ami_return_val,
                                                 const std::string &answer)
{
  CIAOX11_TEST_INFO << "Sender: MyFoo_obj AMI Callback from foo:"
                    << " result <" << ami_return_val << "> answer <" << answer
                    << ">" << std::endl;
}
void
AMI4CCM_MyFoo_objReplyHandler_run_my_foo_i::foo_excep (IDL::traits<::CCM_AMI::ExceptionHolder>::ref_type excep_holder)
{
}
-----------------------------------------------------------------------------------------------------------------------

*Receiver_comp_exec.cpp*

In this file the interface methods must be implemented.

For example the foo method can be implemented as:

[source,c++]
-----------------------------------------------------------------------
int32_t
MyFoo_obj_exec_i::foo (const std::string & in_str, std::string& answer)
{
   answer = "This is my answer : Hi";
   return 100;
}
-----------------------------------------------------------------------


== Compiling and deployment

=== Compiling

Once all the code has been written, compilation of the code would be the
next step.
MPC is used in order to create the Makefiles and projects files. All MPC
files that are needed for this tutorial are in the same directory as the
accompanying IDL or executor files.
In order to make the GNU make files , use *brix11* and perform the
following steps :

* Start a command shell and navigate to : +
 `$CIAOX11_ROOT/connectors/ami4ccm/tutorials/hello/hello_asm`
* Run +
 `$X11_BASE_ROOT/bin/brix11 generate build` to generate the GNU make
files.
* Now compile and link the code using brix11: +
 `$X11_BASE_ROOT/bin/brix11 make`

Alternatively, the GNU make files also can be generated by using a perl
script. +

* Start a command shell and navigate to : +
 `$CIAOX11_ROOT/connectors/ami4ccm/tutorials/hello/hello_asm`
* Run +
 `perl  $TAOX11_BASE__ROOT/bin/mwc.pl -type gnuace` to generate the GNU make files.
* Now compile and link the code like you're used to.

All libraries are put into the hello_asm/lib directory.

=== Deployment

Once all shared libraries are compiled, they're ready to be deployed.
In this tutorial we are using DnCX11 to deploy our system. DnCX11
starts a system in two phases :

1.  configuration_complete
2.  ccm_activate

DnCX11 shuts down a system again in two phases :

1.  ccm_passivate
2.  ccm_remove

Each component should have these four lifecycle methods implemented. The business
logic implemented in each step depends on you implementation. There are
several processes taking care of the total deployment process. See the
<<{xref_docs_root}/dancex11/dancex11.adoc#,DnCX11 documentation>>
for more information about which processes there
are and what their responsibilities are. DnCX11 will start and shutdown
a system with the aid of a deployment plan. A deployment plan describes
which artifacts must run on which nodes and which components are
connected to each other using which interface (more on this later). All
connections between components and connectors are made before
'configuration_complete' is called.

The deployment plan can be crafted by hand or automatically generated by
the modeling tools but we take a brief look at the most important items
of a deployment plan. A deployment plan can be a file with a DnCX11
text base format (CONFIG) or a XML based file (CDP). See
<<{xref_docs_root}/dancex11/deployment-planning.adoc#plan,The
Plan in the DnCX11 documentation>>.

==== DnCX11 CONFIG file

A DnCX11 text based format file (*.config) uses descriptor records. Each
record starts with and is identified by a key identifier. For this
tutorial we have to use 'Component Instance descriptors' for each
component: Sender, Receiver, the CORBA4CCM Connector, and AMI4CCM Connector.
The top level descriptor for an instances defines nested descriptors as
part of that descriptor to define any necessary information for the
other elements (or automatically derives them).

.Component Instance descriptor Receiver component and its CORBA4CCM connector
----------------------------------------------------------------------------------------------------------------------------
#=====================================================
# Definitions for Receiver Node
#-----------------------------------------------------
# ReceiverComponent instance with:
#   component-instance-key = nl.remedy.it.CCM.Component
#   component-instance-id = Hello_ReceiverComponent
#   component-artifact = Hello_Receiver_exec
#   component-factory =  create_Hello_Receiver_comp_Impl
nl.remedy.it.CCM.Component Hello_ReceiverComponent Hello_Receiver_exec create_Hello_Receiver_comp_Impl
  # deployment property descriptor with key nl.remedy.it.DnCX11.ExecParameter:
  nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Hello_Receiver_comp_Servant"
  # deployment node descriptor:
  nl.remedy.it.DnCX11.Node "ReceiverNode"
  # deployment locality descriptor:
  nl.remedy.it.DnCX11.Locality "ReceiverLocality"

# Receiver CORBA4CCM Connector instance
nl.remedy.it.CCM.Component Receiver_CORBA_connector Hello_corba_conn create_Hello_MyFoo_obj_SRR_CORBA_Connector_Impl
  nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Hello_MyFoo_obj_SRR_CORBA_Connector_Servant"
  nl.remedy.it.DnCX11.Node "ReceiverNode"
  nl.remedy.it.DnCX11.Locality "ReceiverLocality"
  # connection to the Receiver component:
  nl.remedy.it.DnCX11.Connection Hello_ReceiverComponent
    srr_receptacle < do_my_foo
----------------------------------------------------------------------------------------------------------------------------


It is for the Sender component possible to have, besides an asynchronous
connection with the AMI4CCM connector, a synchronous connection, called
'synch_foo_connection' with the AMI4CCM connector or with the Receiver
component . +
The synchronous connection with the AMI4CCM connector is described
here, for a definition of the synchronous connection with the Receiver,
see <<Advanced deployment,here>>.

.Component Instance descriptor Sender component
------------------------------------------------------------------------------------------------------------------
#=====================================================
# Definitions for Sender Node
#-----------------------------------------------------
# SenderComponent instance
nl.remedy.it.CCM.Component Hello_SenderComponent Hello_Sender_exec create_Hello_Sender_comp_Impl
  nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Hello_Sender_comp_Servant"
  nl.remedy.it.DnCX11.Node "SenderNode"
  nl.remedy.it.DnCX11.Locality "SenderLocality"
  # the synchronous port on the AMI4CCM connector
  # connector description for connection between this instance (Hello_SenderComponent) and the Hello_AMIConnector,
  # one internalEndpoint description for SimplexReceptacle run_my_foo of this instance :
  # portName is defined as name of port defined in Hello_Sender_comp.idl
  # one internalEndpoint description for Facet ami4ccm_port_ami4ccm_sync_provides of instance Hello_AMIConnector:
  # portName always ami4ccm_port_ami4ccm_sync_provides
  nl.remedy.it.DnCX11.Connection Hello_AMIConnector
    run_my_foo < ami4ccm_port_ami4ccm_sync_provides   # synch_foo_connection
------------------------------------------------------------------------------------------------------------------


_The instance of the AMI4CCM connector uses the same node as the Sender!_

.Component Instance descriptor AMI4CCM connector
--------------------------------------------------------------------------------------------------------------------------------------------
# AMI4CCM ConnectorComponent instance
nl.remedy.it.CCM.Component Hello_AMIConnector Hello_ami4ccm_conn create_Hello_AMI4CCM_MyFoo_obj_Connector_AMI4CCM_Connector_Impl
  nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Hello_AMI4CCM_MyFoo_obj_Connector_AMI4CCM_Connector_Servant"
  nl.remedy.it.DnCX11.Node "SenderNode"
  nl.remedy.it.DnCX11.Locality "SenderLocality"
  # asynchronous connection between Sender and AMI4CCM connector
  # connector description for connection between this instance (Hello_AMIConnector) and the Hello_SenderComponent,
  # one internalEndpoint description for SimplexReceptacle sendc_run_my_foo of instance Hello_SenderComponent:
  # portName is defined as "sendc_" + name of port defined in Hello_Sender_comp.idl
  # one internalEndpoint description for Facet ami4ccm_port_ami4ccm_provides of this instance:
  # portName always 'ami4ccm_port_ami4ccm_provides'.
  nl.remedy.it.DnCX11.Connection Hello_SenderComponent
    ami4ccm_port_ami4ccm_provides > sendc_run_my_foo  # run_asynch_foo_connection
  # synchronous connection between AMI4CCM connector and the CORBA4CCM connector of the Receiver
  # connector description for connection between this instance (Hello_AMIConnector) and the Receiver_CORBA_connector,
  # one internalEndpoint description for SimplexReceptacle ami4ccm_port_ami4ccm_uses of this instance :
  # portName always ami4ccm_port_ami4ccm_uses.
  # one internalEndpoint description for Facet ssr_facet (always) of instance Receiver_CORBA_connector
  nl.remedy.it.DnCX11.Connection Receiver_CORBA_connector
    ami4ccm_port_ami4ccm_uses < srr_facet  # do_foo_connection
--------------------------------------------------------------------------------------------------------------------------------------------

link:{docs_root}/../code/ami4ccm//deployment/descriptors/plan.config[This] file shows the
complete deployment config file.

==== XML based file

An alternative for the DnCX11 Config file is an XML based file (*.cdp),
which is divided into the following (main) sections:

* Implementations
* Entry points
* Instances
* Connections
* Artifacts

_All deployment code fragments mentioned in the rest of this tutorial
are *NOT* exports of any modeling tool._

===== Implementations and Entry Points

This defines which executor and servant artifacts (binaries) should be
used. Implementations also defines which entry points in the binaries
should be used. In this example there are needed four implementation
sections; for the Sender, Receiver, CORBA4CCM connector, AMI4CCM connector.
link:{docs_root}/../code/ami4ccm/deployment/descriptors/implementation.cdp[This] file shows the
implementation section of the AMI4CCM connector. Beware that artifacts
and entry points are exact otherwise deployment will fail.

===== Instances

Instances define which artifacts run on which node. Every physical
artifact in the system results in one instance. The `<node>` section
refers to the physical node on which this instance will be deployed. An
instance always refers to an implementation. It's possible that more
than one instance refers to the same implementation. The instance
section also provide the initial values of all attributes defined on the
component. link:{docs_root}/../code/ami4ccm/deployment/descriptors/instance.cdp[This] file
shows the instance section of the Sender, Receiver, CORBA4CCM connector, and
AMI4CCM connector.

_The instance of the AMI4CCM connector uses the same node as the Sender!_

===== Connections

A connection section defines which components are connected together.
The connection is 'local' since a connector and a component are always
running in the same process. Now that we have got all the data we need
to know to make a connection for the asynchronous methods between the
Sender and AMI4CCM connector (1) and between the AMI4CCM connector and
the CORBA4CCM connector of the receiver (2) and from there to the receiver
itself (3). +
 For the synchronous methods we need an extra connection between the
Sender and AMI4CCM-connector (4). +
 It is also possible to create an extra CORBA4CCM connector for the Sender
in order to handle the synchronous requests. See
<<06_advanced.html#,this page>> for an example of that configuration

.Local connection for async interface between Sender and AMI4CCM connector (1)
------------------------------------------------------------------------------------------------------------------------------------------
<!-- Local asynchronous connection between the Sender and the AMI connector -->
<connection>
  <name>run_asynch_foo_connection</name> <!-- unique name of the connection-->
  <internalEndpoint>  <!-- First endpoint (the Sender component)-->
    <!-- PortName is defined as "sendc_" + name of port defined in Hello_Sender_comp.idl -->
    <portName>sendc_run_my_foo</portName>
    <provider>false</provider>
    <kind>SimplexReceptacle</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Sender" />
  </internalEndpoint>
  <internalEndpoint> <!-- Second endpoint (the AMI4CCM connector component) -->
    <portName>ami4ccm_port_ami4ccm_provides</portName> <!-- PortName always the same -->
    <provider>true</provider>
    <kind>Facet</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.AMI" /> <!-- The reference to the connector instance -->
  </internalEndpoint>
</connection>
------------------------------------------------------------------------------------------------------------------------------------------

.Remote connection for sync interface between AMI4CCM connector and CORBA4CCM connector (2)
----------------------------------------------------------------------------------------------------
<!-- Remote synchronous between the AMI connector and the CORBA4CCM connector of the Receiver -->
<connection>
  <name>do_foo_connection</name>
  <internalEndpoint> <!-- First endpoint (the CORBA4CCM connector of the Receiver) -->
    <portName>srr_facet</portName>  <!-- PortName always the same -->
    <provider>true</provider>
    <kind>Facet</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Receiver.CORBA" />
  </internalEndpoint>
  <internalEndpoint> <!-- Second endpoint (the AMI connector) -->
    <portName>ami4ccm_port_ami4ccm_uses</portName>  <!-- PortName always the same -->
    <provider>false</provider>
    <kind>SimplexReceptacle</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.AMI" />
  </internalEndpoint>
</connection>
----------------------------------------------------------------------------------------------------

.Local connection for sync interface between CORBA4CCM connector and Receiver (3)
---------------------------------------------------------------------------------------------------------
<!-- Local synchronous connection between the CORBA4CCM connector of the Receiver and the Receiver itself -->
<connection>
  <name>do_foo_connection_cc</name>
  <internalEndpoint>  <!-- First endpoint (the Receiver component)-->
    <portName>do_my_foo</portName>
    <provider>true</provider>
    <kind>Facet</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Receiver" />
  </internalEndpoint>
  <internalEndpoint> <!-- Second endpoint (the CORBA4CCM connector of the Receiver)-->
    <portName>srr_receptacle</portName> <!-- PortName always the same -->
    <provider>false</provider>
    <kind>SimplexReceptacle</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Receiver.CORBA" />
  </internalEndpoint>
</connection>
---------------------------------------------------------------------------------------------------------

.Local connection for sync interface between Sender and AMI4CCM connector (4)
---------------------------------------------------------------------------------------------
<!-- Local synchronous connection between the Sender and the AMI connector -->
<connection>
  <name>synch_foo_connection</name>
    <internalEndpoint>
    <portName>ami4ccm_port_ami4ccm_sync_provides</portName> <!-- PortName always the same -->
    <provider>true</provider>
    <kind>Facet</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.AMI" />
  </internalEndpoint>
  <internalEndpoint>
    <portName>run_my_foo</portName>
    <provider>false</provider>
    <kind>SimplexReceptacle</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Sender" />
  </internalEndpoint>
</connection>
---------------------------------------------------------------------------------------------

Take a look at link:{docs_root}/../code/ami4ccm/deployment/descriptors/connections.cdp[this]
file to see which connection should be made by DnCX11 in order to run
the Hello tutorial properly.

When the deployment tools (in this case DnCX11) deploys this system,
it'll connect all defined connectors before the system is started (i.e.
before configuration_complete is called on a component).

===== Complete XML plan

link:{docs_root}/../code/ami4ccm/deployment/descriptors/plan.cdp[This] file shows the complete
deployment plan.

=== Coding connections

Every component has got a context. The context is set by CIAOX11 and is
the 'gateway' to all other component your component is connected to. The
context caches all these connections so that the user doesn't need to
cache those in his/her component.

*Sender:*

The following code retrieves the connection to the AMI4CCM connector
interface from the context:

[source,c++]
-----------------------------------------------------------------
IDL::traits<::Hello::AMI4CCM_MyFoo_obj>::ref_type my_foo_ami_  =
       this->context_->get_connection_sendc_run_my_foo();
-----------------------------------------------------------------

The following code retrieves the connection to the Receiver interface
from the context:

[source,c++]
-----------------------------------------------------------------------------------------------
IDL::traits<Hello::MyFoo_obj>::ref_type my_foo_ = this->context_->get_connection_run_my_foo ();
-----------------------------------------------------------------------------------------------

*Receiver:*

The Receiver provide one facet for the AMI4CCM connector and for the
sender.

[source,c++]
--------------------------------------------------------------------
IDL::traits<Hello::CCM_MyFoo>::ref_type
  Receiver_exec_i::get_do_my_foo (void)
{  return CORBA::make_reference <do_my_foo_exec_i> (this->context_);
}
--------------------------------------------------------------------

== Running the tutorial

When the tutorial is build, it is possible to run it with the `brix11 run
test` command or the perl script
link:{docs_root}/../../ciaox11/connectors/ami4ccm/tutorials/hello/hello_asm/deployment/scripts/run_test.pl[run_test.pl]. +
 Start a command shell and navigate to : +

`$CIAOX11_ROOT/connectors/ami4ccm/tutorials/hello/hello_asm/deployment/scripts`

Starting `$X11_BASE_ROOT/bin/brix11 run test` without arguments, the
test will use the `plan.config` file for deployment, starting with the options `-- -fmt cdp`
added to the command, the test will use the `plan.cdp` file for deployment.

Starting `perl run_test.pl` without arguments, the script will use the
`plan.config` file for deployment, starting with the argument `-fmt cdp`,
the script will use the `plan.cdp` file for deployment.

== Advanced deployment

So far, this tutorial explained how to use asynchronous- and synchronous
connections between Sender and AMI4CCM connector, but as as mentioned
briefly before, the synchronous connection between the Sender and
Receiver component can be established in two ways. The second option
(ignoring the AMI4CCM connector but use a CORBA4CCM connector on the sender
side instead) is shown below

image:{images_root}/ami4ccm/synrec.png[image]

Using one or the other is a matter of using the correct configuration in
the deployment plans.

For the *config* plan , the Sender side instance must become:

------------------------------------------------------------------------------------------------------------------------------
# SenderComponent instance
nl.remedy.it.CCM.Component Hello_SenderComponent Hello_Sender_exec create_Hello_Sender_comp_Impl
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Hello_Sender_comp_Servant"
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"
    nl.remedy.it.DnCX11.Connection Sender_CORBA_connector
      run_my_foo < srr_facet # synch_foo_connection

nl.remedy.it.CCM.Component Sender_CORBA_connector Hello_corba_conn create_Hello_MyFoo_obj_SRR_CORBA_Connector_Impl
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Hello_MyFoo_obj_SRR_CORBA_Connector_Servant"
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"
    nl.remedy.it.DnCX11.Connection Receiver_CORBA_connector
      srr_receptacle < srr_facet
------------------------------------------------------------------------------------------------------------------------------

In the *CDP* plan, we need an extra instance of the CORBA4CCM connector:

-----------------------------------------------------------------------------------------
<instance xmi:id="Hello.ComponentImplementations.HelloImplementation.Hello.Sender.CORBA">
  <name>Hello.ComponentImplementations.HelloImplementation.Hello.Sender.CORBA</name>
  <node>SenderNode</node>
  <source/>
  <implementation xmi:idref="Hello_CORBAConnector"/>
  </instance>
-----------------------------------------------------------------------------------------

and then we need to create the connections to and from this instance:

--------------------------------------------------------------------------------------------------
<!-- Local synchronous connection between the Sender and the CORBA4CCM connector of the Sender -->
<connection>
  <name>synch_foo_connection_sender</name>
  <internalEndpoint>
    <portName>run_my_foo</portName>
    <provider>false</provider>
    <kind>SimplexReceptacle</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Sender" />
  </internalEndpoint>
  <internalEndpoint>
    <portName>srr_facet</portName> <!-- PortName always the same -->
    <provider>true</provider>
    <kind>Facet</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Sender.CORBA" />
  </internalEndpoint>
</connection>
--------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
<!-- Remote synchronous connection between the CORBA4CCM connector of the Sender and the CORBA4CCM connector of the Receiver -->
<connection>
  <name>synch_foo_connection_cc_cc</name>
  <internalEndpoint>
    <portName>srr_receptacle</portName>  <!-- PortName always the same -->
    <provider>false</provider>
    <kind>SimplexReceptacle</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Sender.CORBA" />
  </internalEndpoint>
  <internalEndpoint>
    <portName>srr_facet</portName> <!-- PortName always the same -->
    <provider>true</provider>
    <kind>Facet</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Receiver.CORBA" />
  </internalEndpoint>
</connection>
------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------
<!-- Local synchronous connection between the CORBA4CCM connector of the Receiver and the Receiver itself -->
<connection>
  <name>do_foo_connection_cc</name>
  <internalEndpoint>
    <portName>do_my_foo</portName>
    <provider>true</provider>
    <kind>Facet</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Receiver" />
  </internalEndpoint>
  <internalEndpoint>
    <portName>srr_receptacle</portName> <!-- PortName always the same -->
    <provider>false</provider>
    <kind>SimplexReceptacle</kind>
    <instance xmi:idref="Hello.ComponentImplementations.HelloImplementation.Hello.Receiver.CORBA" />
  </internalEndpoint>
</connection>
---------------------------------------------------------------------------------------------------------
