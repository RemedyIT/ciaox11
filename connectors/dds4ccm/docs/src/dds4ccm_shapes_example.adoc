include::_{backend}_settings.adoc[]

= DDS4CCM shapes example

== General

This tutorial explains how to use a DDS4CCM connector in combination
with an LwCCM component.

Knowledge of the https://www.omg.org/spec/DDS4CCM[DDS4CCM for LwCCM
specification] as well as knowledge of pass:[IDL3+] is assumed.
For this tutorial the link:{docs_root}/ciaox11/axcioma_project_tool.html[BRIX11 AXCIOMA Project Control] (APC) tools
are used, which are a set of link:{docs_root}/brix11/brix11.html[BRIX11] command extensions with the intent of providing simplified and
consistent project management for AXCIOMA based applications.

=== System

The system consists of three components:

* Sender component
* Receiver component
* Controller component

In this tutorial DDS is used to transfer data from the sender to the
receiver. Since the sender and receiver are separate components, each
uses a DDS4CCM connector which is deployed collocated with the user
component.

The exchanged data is defined as a struct (`ShapeType`) with the following
members:

[cols="<1,<1m,<3",options="header",]
|=========================================
|Member |Type |Functionality
|color |string<128> |Represents the color of the shape
|x |long |Represents the location on the x-axis
|y |long |Represents the location on the y-axis
|shapesize |long |Represents the size of the shape
|=========================================

Separate DDS Topics are used to represent different kind of shapes,
i.e., Circle, Square, and Triangle. The color field is a DDS "key"
value, which causes DDS to treat each color as an unique "instance" of a
shape. Each of these instances are registered with DDS and is
independently maintained in regards to Quality of Service (QoS)
settings. The controller component controls the location and size of the
shape. The sender registers a shape instance with DDS and
transfers the data received from the controller to DDS. The receiver
listens to DDS and receives the updates regarding the shapes data.

image:{images_root}/dds4ccm/system.png[image]

This tutorial application works in conjunction with the
https://www.rti.com/free-trial/shapes-demo[RTI Connext DDS Shapes demo].

=== Interaction patterns

Two interaction patterns are used in this tutorial:

* Synchronous request/reply
* Event

The synchronous request/reply pattern is implemented by a
<<{xref_docs_root}/corba4ccm/corba4ccm.adoc#,CORBA4CCM connector>> and the
event pattern by a
<<{xref_docs_root}/dds4ccm/dds4ccm.adoc#,DDS4CCM connector>>. The
tutorial will explain where and how these connectors will be used.

=== Directory structure

The following directory structure convention is used:

[source]
-------------------
/<root>         : Directory contains the project recipe
  /ports        : Directory contains common IDL code for the project and the recipes for the connectors
  /*_comp       : Directory contains a component
    /src        : Directory contains the recipes, the IDL and *_exec-files for the component
-------------------

=== IDL file naming convention

The following convention is used to name the IDL files:

[cols="<m,<5",options="header",]
|=========================================
|File name |Content description
| *_defn.idl | Will contain definitions, like enumerations, constants and so on. Typically located in `./ports`
| *_msg.idl | Will contain the messages (data structure) published to DDS. Typically located in `./ports`
| *_obj.idl | Will contain the interfaces between components. Typically located in `./ports`
| *_comp.idl | Will contain the component declaration. Typically located in `./*_comp/src`
|=========================================

=== Additional conventions

Recipe files  (**.aprc*) are located in the same directory as the IDL and (for components) executor
files. Each component has a single recipe in its own recipe file. For the CORBA4CCM connector
and the DDS4CCM connector there are also separate recipes in separate recipe files.

pass:[C++] source code files that are generated by the RIDL compiler or the RTI Connext DDS
compiler are located in a subdirectory, except the component executor
starter code. The default name of this subdirectory is `generated_code`
unless 'gen_dir' is specified in the recipes to change this default.

=== Typical work flow

The following work flow is suitable in most cases. All steps will be
handled in more detail in this tutorial:

.  Define your (DDS) data types in IDL
.  Optionally define your interfaces in IDL
.  Define your components in IDL
.  Create recipe files
.  Generate your build files from the recipe files using the <<../ciaox11/axcioma_project_tool#_apc_prepare,BRIX11 APC prepare>> command
.  Do an initial compilation of your component, the RIDL compiler will
   generate your component executor starter code during this step. The easiest way is to use the
   <<../ciaox11/axcioma_project_tool#_apc_make,BRIX11 APC make>> command which will build your
   complete application
.  Implement your component business logic
.  Compile your components
.  Create your deployment plan
.  Deploy your application

=== DDSX11

DDS4CCM is implemented using DDSX11. DDSX11 provides the DDS API
according to the IDL to {cxx11} language mapping. Using DDSX11 you can
implement DDS applications in a completely vendor agnostic way.
Conversion between the DDS vendor specific types and the IDL to {cxx11}
generated types is generated by the RIDL compiler.
An example of publishing a ShapeType to DDS is
link:{docs_root}/../../ciaox11/ddsx11/examples/shapes/sender/sender.cpp[ddsx11/examples/shapes/sender/sender.cpp].
An example of subscribing to a ShapeType is
link:{docs_root}/../../ciaox11/ddsx11/examples/shapes/receiver/receiver.cpp[ddsx11/examples/shapes/sender/receiver.cpp].

== IDL files

IDL files are often generated by modeling tools but for this
tutorial we create them manually. Below is an overview
of the IDL files we use in this tutorial.

=== DDS4CCM IDL

The DDS4CCM specification describes the behavior and IDL
definition a DDS4CCM implementation should be compliant to. This
*AXCIOMA* DDS4CCM IDL definition can be found
link:{docs_root}/../../ciaox11/connectors/dds4ccm/idl/ccm_dds.idl[here].

=== Data type IDL files

Below a simplified representation of the IDL files that define the
data types we use in this tutorial. Use the links to view the file itself.
The following IDL files can be found in `shapes_asm/ports`:

.link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/ports/shapes_defn.idl[shapes_defn.idl]
[source,idl]
-------------------
module Shapes
{
  enum ReturnStatus
  {
    RETURN_OK,
    RETURN_ERROR
  };
};
-------------------

.link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/ports/shapes_shapetype_msg.idl[shapes_shapetype_msg.idl]
[source,idl]
--------------------------
typedef string<128> color_type;

struct ShapeType
{
  color_type color; //@key
  long x;
  long y;
  long shapesize;
};
--------------------------

The `ShapeType` struct is the the data structure that is published by the
sender to DDS. In DDS, a single instance of this struct is called a
sample.

This IDL file will be compiled by the
<<{xref_docs_root}/taox11/ridlc.adoc#,RIDL compiler>> and,
in order for DDS4CCM to be truly vendor agnostic, this results, besides
the regular stub files, in a implied IDL file called
`shapes_shapetype_msg_dds.idl` in the `generated_code` subdirectory. This
file is used as input for the RTI Connext DDS code generator (rtiddsgen).
The key value for this struct is defined with `//@key)` as shown above.
The key value indicates to DDS that QoS features may apply to every
unique instance of the color field (e.g. a "red" square is a different
instance than a "green" square).


=== Controller IDL files

The controller is used to modify the location and the size of the
registered shape by invoking synchronous methods on the sender
component. These methods are part of an interface which the sender
provides and is used by the controller. A synchronous
request/reply pattern is used between the controller and the sender
component.

The IDL looks like:

.controller interface declaration in link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/ports/shapes_control_obj.idl[shapes_asm/ports/shapes_control_obj.idl]
[source,idl]
-------------------------------------------------------
module Shapes
{
  interface Control_obj
  {
    /// Set the size of the shape we are publishing
    ReturnStatus setSize (in unsigned short size);

    /// Set the location of the shape we are publishing
    ReturnStatus setLocation (in unsigned short x,
                              in unsigned short y);
  };
};
-------------------------------------------------------

The controller component periodically calls (triggered by a
link:{docs_root}/tt4ccm/tt4ccm.html[Timed Trigger connector])
the `setSize` and `setLocation`
methods on the sender component. A Timed Trigger connector provides
the interface `CCM_TT::TT_Scheduler` for components to schedule timer events.

The component IDL file looks like this.

.controller component IDL in link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_control_comp/src/shapes_control_comp.idl[shapes_asm/shapes_control_comp/src/shapes_control_comp.idl]
[source,idl]
--------------------------------------
module Shapes
{
  component Control_comp
  {
    uses Shapes::Control_obj control;
    uses CCM_TT::TT_Scheduler tt_scheduler;

    attribute unsigned long rate;
    attribute unsigned short max_x;
    attribute unsigned short max_y;
    attribute unsigned short max_size;
    attribute boolean resize_shape;
  };
};
--------------------------------------

The controller uses the `Shapes::Control_obj` interface.

The following attributes are defined:

[cols="<,<5",options="header",]
|=========================================
|Attribute |Functionality
|rate |Controls the rate in which the controller component sends updates to the sender
|max_x |Sets the width of the rectangle shaped window
|max_y |Sets the height of the rectangle shaped window
|max_size |Set the maximum size of the registered shape
|resize_shape |Indicates whether the shape is resizeable
|=========================================

The attributes receive their initial values from the deployment tools and
cannot be changed from outside the component instance throughout the life-cycle of the
controller component. When there is a requirement that the attribute values have to be
modified during runtime the component has to provide a separate, explicit, port for this feature.

=== Sender IDL file

When the controller invokes `setSize` or `setLocation` the sender
uses the received size and location to update the `ShapeType` struct.
Following that the sender publishes the updated struct to DDS by calling
`write_one` on the `DDS_Write` port. The IDL file of the Sender component
looks like:

.sender component IDL link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_sender_comp/src/shapes_sender_comp.idl[shapes_asm/shapes_sender_comp/src/shapes_sender_comp.idl]
[source,idl]
----------------------------------------------
module Shapes
{
  component Sender_comp
  {
    port ShapeType_conn::DDS_Write info_write;
    provides Shapes::Control_obj control;
  };
};
----------------------------------------------

The Sender uses the DDS_Write port of the DDS4CCM connector to write
(publish) data to DDS, using the data event interaction pattern. +
 The Sender provides the `Shapes::Control_obj` interface to the
Controller component. This means that the sender component implements a
facet representing the `Shapes::Control_obj` interface allowing the
controller component to invoke the methods in this interface.

=== Receiver IDL file

The receiver is "_listening_" to DDS. Once the shape has been updated by
the sender, DDS will invoke a callback method on the DDS4CCM connector
which in turn calls the receiver component. As part of this callback the
DDS4CCM connector will pass the received data to the receiver
component. +
The receiver should provide the DDS4CCM connector with an interface
which the DDS4CCM connector should invoke the moment it gets a callback
from DDS. To enable this, the receiver component IDL should look like
this:

.receiver component IDL link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_receiver_comp/src/shapes_receiver_comp.idl[shapes_asm/shapes_receiver_comp/src/shapes_receiver_comp.idl] +
[source,idl]
---------------------------------------------
module Shapes
{
  component Receiver_comp
  {
    port ShapeType_conn::DDS_Listen info_out;
  };
};
---------------------------------------------

== Recipe files

An APC based project contains one <<../ciaox11/axcioma_project_tool#_project_recipe,project recipe file>> and one or more
<<../ciaox11/axcioma_project_tool#_application_recipes,application recipe files>> where the recipes for the application
artifacts are defined.

=== Project recipe file

An APC based project is assumed to be stored in a directory tree with a single common root.This root is
marked by the existence of a project recipe file stored at that location using a fixed name (`aprc`).
The project recipe contains the directories where the data and interface IDL files are located. +
In this tutorial it contains `prj.idl_includes %w{ ports }`, because
it is the ports directory in this shapes tutorial where the common data IDL files are located.

.project recipe in link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/aprc[shapes_asm/aprc]
[source,ruby]
--------------------------
prj.idl_includes %w{ ports }
--------------------------

=== Application recipes

APC defines various recipe types for different application products like
connectors, components and optionally data. Product recipes are stored
in text files using APC DSL (Domain Specific Language) definitions. A
recipe file can have any name ending with a fixed extension ('.aprc').
See also <<../ciaox11/axcioma_project_tool#_application_recipes,here>> for more details.

For the shapes tutorial we use recipe files for the
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_sender_comp/src/sender.aprc[sender
component], the
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_receiver_comp/src/receiver.aprc[receiver
component], the
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_control_comp/src/shapes_control.aprc[control
component], the
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/ports/event_dds4ccm_conn.aprc[dds4ccm
connector], and the
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/ports/control_corba4ccm_conn.aprc[corba4ccm
connector].
A single recipe file can contain zero or more recipe definitions, but
in this tutorial each recipe file contains one recipe definition.
For the data IDL files, such as the shapes_defn.idl, no recipe is
necessary. APC makes an implicit recipe when it notes that this IDL file
is needed by other IDL files referenced in the project.

==== Component recipes

For a component several properties can be set in the recipe. In case an optional property is
not set, the default is applied. See <<../ciaox11/axcioma_project_tool.html#_component_recipe,here>> for an overview of possible properties. +
As you can see in the recipe of the shapes_control_comp component, this
recipe specifies an additional include path with `comp.includes` and the output path for the
generated code with `comp.gen_dir`.

[source, ruby]
-----------------------------------------
component 'shapes_control_comp' do |comp|
  comp.idl %w{ shapes_control_comp.idl }
  comp.includes %w{ ../../shapes_utils }
  comp.gen_dir  'build'
end
-----------------------------------------

==== Connector recipes

The CORBA4CCM connector recipe for the control interface looks like:

[source, ruby]
---------------------------------------
connector 'control_conn' do |conn|
  conn.idl %w{ shapes_control_obj.idl }
  conn.port_type :corba4ccm
  conn.gen_dir  :conn_dir_build
end
---------------------------------------

Here also a custom output path for generated code is defined.

For the DDS4CCM connector, additional port specifications are necessary.
The DDS4CCM connector recipe used in this tutorial looks like:

[source, ruby]
-----------------------------------------
connector 'shapes_shapetype' do |conn|DDS4CCM
  conn.idl %w{ shapes_shapetype_msg.idl }
  # ...
  conn.port_type :dds4ccm do |tp|
    tp.topic 'ShapeType'
  end
  # ...
end
-----------------------------------------

The `topic` property specifies the data (event) type the connector should support
for read and write operations in it's interface.

Based on this information the APC tool will automatically generate an IDL file
declaring the state/event interface types for the connector to use. The name for
this file is based on the IDL file specified in the connector recipe which in
this case results in `shapes_shapetype_msgSE.idl`.

.shapes_shapetype_msgSE.idl
[source, idl]
-----------------------------------------------------------------------
#include "shapes_shapetype_msg.idl"

typedef sequence<ShapeType> ShapeTypeSeq;

module ::CCM_DDS::Typed<ShapeType, ShapeTypeSeq> ShapeTypeInterface;
-----------------------------------------------------------------------

For connectors several other properties can be set in the recipe. See
<<../ciaox11/axcioma_project_tool#_connector_recipe,here>> for an overview of possible properties.

==== Base recipes

For the data IDL files, such as the `shapes_defn.idl`, no recipe is
necessary. APC creates implicit recipes when it determines
an IDL file is needed by other IDL files referenced in a project.
See <<../ciaox11/axcioma_project_tool#_base_recipe,here>> for more information on these recipes.

== Compile

=== AXCIOMA Project Control tools

In this tutorial we use the BRIX11 AXCIOMA Project Control tools (APC) to generate the make files (Linux) or
the solution/VC-project files (Windows) and build the application. +

APC makes sure that the commandline parameters for the {cpp} compiler are
used correct and consistent throughout the AXCIOMA/DDS4CCM core as well
as the user's business logic.
Also the commandline options for the RIDL compiler are used in a
consistent way.
This part of the tutorial describes how to use APC throughout this
tutorial.

=== Component executor starter code

Once the IDL is written the user should implement the component executor
business logic. To make it easier for the user, the RIDL compiler is
able to generate the initial component executor starter code. This
results in a {cxx11} source code file where:

* The facet executor classes are provided
* The components attributes are declared as private class members
* The getter and setter methods for attributes are declared and implemented
* The facet factory methods are implemented
* The life cycle methods are also available.

The RIDL compiler also makes sure that when the IDL is changed, the
component executor is updated without loosing your existing business code.
Therefor it uses so called re-generation markers throughout the
component executor code. Re-generation markers look like this:

[source,c++]
-------------------------------------------------------------------------------------------------
//@@{__RIDL_REGEN_MARKER__} - BEGIN : Shapes_Control_comp_Impl::Control_comp_exec_i::rate[getter]
return this->rate_;
//@@{__RIDL_REGEN_MARKER__} - END : Shapes_Control_comp_Impl::Control_comp_exec_i::rate[getter]
-------------------------------------------------------------------------------------------------

All code between these markers will be preserved when the executor code
is re-generated, except (off course) when the rate-attribute will be
removed from IDL. An example of an (implemented) component executor code
file can be found
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_control_comp/src/shapes_control_comp_exec.cpp[here]

Re-generation is enabled by default with the regular AXCIOMA distributions. Removing the entry `ciaox11_noregen_exec=0`
from the `default.features` file (located in `$ACE_ROOT/bin/MakeProjectCreator/config`) would disable regeneration.

=== Generating makefiles

To run APC, in order to generate all makefiles for a project execute the following command from any project directory
(under `$CIAOX11_ROOT/connectors/dds4ccm/examples/apc/shapes_asm`):

`/path/to/brix11 apc prepare` +
or +
`/path/to/brix11 apc prepare -m`

With the `-m` option the transient MPC files are not removed
after the makefiles are generated. Default, without this option, the
MPC files are removed after the makefiles are generated.

NOTE: An additional command to remove all generated directories and files from the `apc prepare` command is: +
`/path/to/brix11 apc clean`

=== Compiling

Execute the following command from any project directory:

`/path/to/brix11 apc make`

This will compile the IDL and the (generated) C++11 code. Notice that
all code will be generated in the subdirectory `generated_code` or in the subdirectory
indicated in the recipes with the `gen_dir` property, except the component executor code files
(*_exec.cpp and *_exec.h) as these are not considered transient files and are kept at the same
location as other non-transient files like the recipe files. All libraries are collected in
the `lib` subdirectory.

If the compilation succeeds successfully the application is ready to be deployed when a deployment plan
has been set up.
In case of a newly created project this would also work but would achieve little as the (newly) generated
component executors would not have any business code added yet. In this tutorial the business code for the
executors has already been added and the executor files have merely been regenerated leaving the business
code intact. The tutorial application is therefor ready for deployment.

== Coding

=== Coding

All what would be left before the actual deployment of a new application would be the
implementation of the business code.
For this tutorial that implementation has been included. Please have a look at the following
implementation files to check out that implementation:

Controller::

** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_control_comp/src/shapes_control_comp.idl[IDL]
** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_control_comp/src/shapes_control_comp_exec.cpp[Source]
** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_control_comp/src/shapes_control_comp_exec.h[Header]

Sender::

** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_sender_comp/src/shapes_sender_comp.idl[IDL]
** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_sender_comp/src/shapes_sender_comp_exec.cpp[Source]
** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_sender_comp/src/shapes_sender_comp_exec.h[Header]

Receiver::

** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_receiver_comp/src/shapes_receiver_comp.idl[IDL]
** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_receiver_comp/src/shapes_receiver_comp_exec.cpp[Source]
** link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_receiver_comp/src/shapes_receiver_comp_exec.h[Header]

Compilation of this tutorial will generate the following "functional"
libraries. These libraries will be mentioned in the deployment plan
(next step in this tutorial).

[cols="<m,<3",options="header",]
|=======================================================================
|Library |Purpose

|shapes_control_comp_exec.so |Contains the executor implementation of the
Controller component

|shapes_control_comp_svnt.so |Contains the framework integration parts of the
Controller component

|controll_conn_corba_conn.so |Contains the implementation of the CORBA
connector for the Controller interface.

|shapes_receiver_comp_exec.so |Contains the executor implementation of the
Receiver component

|shapes_receiver_comp_svnt.so |Contains the framework integration parts of the
Receiver component

|shapes_sender_comp_exec.so |Contains the executor implementation of the Sender
component

|shapes_sender_comp_svnt.so |Contains the framework integration parts of the Sender
component

|shapes_shapetype_dds_conn.so |Contains the implementation of DDS4CCM
connector for "ShapeType"
|=======================================================================


== Deployment

=== Deployment

To deploy an application good knowledge about the distribution of components and connectors
over the (computing nodes of the) system is required. Therefor an overview of the system
again but now with node division:

image:{images_root}/dds4ccm/system_nodes.png[image]

In order to deploy an application a deployment plan and
deployment tools are neeed. *AXCIOMA* provides a set of deployment tools for which
the documentation can be found
<<{xref_docs_root}/dancex11/dancex11.adoc#,here>>. +
The *AXCIOMA* deployment tools support two types of deployment plans:
an XML-based plan and a CONFIG based plan. These plans are typically
generated by the modeling tools. Only the latter will be discussed here.
For more information about this format, please have a look at the
deployment tool documentation regarding
<<{xref_docs_root}/dancex11/config-plan.adoc#,plans>>.

=== An example

The part of the
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/deployment/descriptors/plan.config[config plan] that
deals with the Sender node is shown below. +
The first section of this
part of the plan declares the locality (SenderLocality), indicating its
name and on which node it runs (SenderNode). +
The second section declares the Sender component itself, listing the node
on which it should run (SenderNode) and in which locality it should be
deployed (SenderLocality). +
The third section declares the DDS4CCM Connector for the Sender
component. Besides the node and the locality property, it also has two
ConfigProperties ("topic_name" and "domain_id" which are attributes of
the DDS4CCM connector). It also declares the connection between this
connector and the Sender component. +
The fourth and last section declares the CORBA4CCM connector which
implements the synchronous request/reply interaction pattern for the
Controller interface. The declaration of the connections to and from
this connector are part of this section.

----
#=====================================================
# Definitions for Sender Node/Locality
#-----------------------------------------------------
# locality manager instance for locality "SenderLocality" on Node "SenderNode"
nl.remedy.it.DnCX11.LocalityManager SenderComponentServerInstance
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"

# SenderComponent instance
nl.remedy.it.CCM.Component SenderComponent shapes_sender_comp_exec create_Shapes_Sender_comp_Impl
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Artifact "shapes_sender_comp_svnt"
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Shapes_Sender_comp_Servant"
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"

# DDS4CCM_Sender_Connector instance
nl.remedy.it.CCM.Component DDS4CCM_Sender_Connector shapes_shapetype_dds_conn create_ShapeTypeInterface_DDS_Event_Impl
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Artifact "shapes_shapetype_dds_conn"
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_ShapeTypeInterface_DDS_Event_Servant"
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"
    nl.remedy.it.DnCX11.ConfigProperty topic_name "Square"
    #nl.remedy.it.DnCX11.ConfigProperty domain_id int32:0 # enable this to work with the RTI demo.
    nl.remedy.it.DnCX11.Connection SenderComponent
      supplier_data > info_write_data

# CORBA_Connector_Sender_Component
nl.remedy.it.CCM.Component CORBA_Connector_Sender_Component control_conn_corba_conn create_Shapes_Control_obj_SRR_CORBA_Connector_Impl
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Shapes_Control_obj_SRR_CORBA_Connector_Servant"
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"
    # local connection between CORBA connector for the Sender component
    # and the Sender component itself.
    nl.remedy.it.DnCX11.Connection SenderComponent
      srr_receptacle < control
    # Remote connection between the CORBA connector of the Sender component
    # and the CORBA connector of the Control Component
    nl.remedy.it.DnCX11.Connection CORBA_Connector_Control_Component
      srr_facet > srr_receptacle
----

Some highlights of this part of the plan:

----
nl.remedy.it.CCM.Component SenderComponent shapes_sender_comp_exec create_Shapes_Sender_comp_Impl
----
This line declares a component instance with unique id `SenderComponent` and executor library `shapes_sender_comp_exec`
having an executor factory entrypoint `create_Shapes_Sender_comp_Impl`.

----
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Artifact "shapes_sender_comp_svnt"
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Shapes_Sender_comp_Servant"
----

Declaration of which library contains the servant code and which entrypoint to use for the servant.

----
    nl.remedy.it.DnCX11.ConfigProperty topic_name "Square"
    #nl.remedy.it.DnCX11.ConfigProperty domain_id int32:0 # enable this to work with the RTI demo.
----

Initial values for the attributes (`topic_name` and `domain_id`).

----
nl.remedy.it.CCM.Component DDS4CCM_Sender_Connector shapes_shapetype_dds_conn create_ShapeTypeInterface_DDS_Event_Impl
    ...
    nl.remedy.it.DnCX11.Connection SenderComponent
      supplier_data > info_write_data
----

Declares the connection from the DDS4CCM connector to the Sender component. We connect the "Writer"
interface (called `data`) of the "DDS_Write" port (called `supplier`)
on the DDS4CCM Event connector to the "Writer" interface (called "data")
of the "DDS_Write" port (called "info_write") on the Sender component.
(see link:{docs_root}/../../ciaox11/connectors/dds4ccm/idl/ccm_dds.idl[DDS4CCM IDL] and
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/shapes_sender_comp/src/shapes_sender_comp.idl[Sender component IDL]
for more information). +
Combining this all gives: `supplier_data > info_write_data`. +
A connection statement always begins with the extended port name
(<port_name>_<interface_name>) of the current connector/component and
ends with the extended port name of the other connector/component. The
connector symbol (`<` or `>`) points from the facet to the receptacle.

----
nl.remedy.it.CCM.Component CORBA_Connector_Sender_Component control_conn_corba_conn create_Shapes_Control_obj_SRR_CORBA_Connector_Impl
    ...
    nl.remedy.it.DnCX11.Connection SenderComponent
      srr_receptacle < control
    # Remote connection between the CORBA connector of the Sender component
    # and the CORBA connector of the Control Component
    nl.remedy.it.DnCX11.Connection CORBA_Connector_Control_Component
      srr_facet > srr_receptacle
----

The CORBA4CCM connector has two connections: one (remote) connection to the CORBA4CCM
connector of the Controller Component and one to the Sender. These are declared the same
way as the connection on the DDS4CCM Event connector. +
For more info regarding CORBA4CCM connectors and their connections, please
see <<{xref_docs_root}/corba4ccm/corba4ccm.adoc#,this page>>.

The other sections of the config plan look similar. +
Note that for the Controller also a (standard) Timed Trigger Connector must be deployed on the same node and locality as the Controller:

----
# TimedTriggerProvider instance
nl.remedy.it.CCM.Component TimedTriggerProvider ciaox11_tt4ccm_conn create_CIAOX11_TT_TimedTrigger_Impl
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_CIAOX11_TT_TimedTrigger_Servant"
    nl.remedy.it.DnCX11.Node "ControlNode"
    nl.remedy.it.DnCX11.Locality "ControlLocality"
----

== Running

=== Run time

Information about the execution model of the *AXCIOMA* deployment tools
can be found
<<{xref_docs_root}/dancex11/deployment-execution.adoc#,here>>.

In *AXCIOMA* every example/test is accompanied by a Perl script. This
Perl script contains the execution steps which are necessary to deploy
the example or test. Have a look at the Perl script of this tutorial
which can be found
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/deployment/scripts/run_test.pl[here]. As you
can see there this deployment uses the CORBA naming service. Alternatively, if you do not want to use
the CORBA naming service, you can use a CDD (Component Deployment Domain) file. See this
link:{docs_root}/../../ciaox11/connectors/dds4ccm/examples/shapes_asm/deployment/scripts/run_test_cdd.pl[version] of the script
to see how the tutorial can be deployed without using the CORBA naming
service.

=== DDS Domain ID

DDS supports the concept of "_domains_". Domains within DDS are configured
by using unique numeric domain ID's. Only DDS participants within the
same domain are able to communicate with each other. There are two ways
to define a domain ID for a DDS4CCM connector:

.  Setting the `DDS4CCM_DEFAULT_DOMAIN_ID` environment variable
.  Setting the `domain_id` property in the deployment plan (see previous page).

By default DDS4CCM retrieves the value using the environment variable.
This value can be overridden by configuring the domain id in the
deployment plan.

=== Logging

The following environment variables will turn all DDS4CCM logging on:

---------------------------------------------------------------------
DDS4CCMX11_LOG_MASK='all'
DDS4CCMX11_LOG_VERBOSITY='prio|thread|process|time|datetime|category'

DDSX11_LOG_MASK='all'
DDSX11_LOG_VERBOSITY='prio|thread|process|time|datetime|category'

---------------------------------------------------------------------

More information about which values can be used for the above mentioned
environment variables can be found <<{xref_docs_root}/taox11/x11_logging.adoc#,here>>.

