/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#include "hello2_cc_exec.h"

#include "connectors/corba4ccm/corba4ccm/corba4ccm_conn_t.h"
// generated from exf4cc/templates/comp_exec/src/corba/exf/pre_exf
#include "exf/deployment/core/ciaox11_exf_util.h"
#include "exf/deployment/amh/ciaox11_exf_exec_base.h"

// generated from corba4ccm/templates/comp_exec/src/corba/exf/component
namespace Hello_B_SRR_CORBA_Connector_Impl
{

  // generated from corba4ccm/templates/comp_exec/src/corba/exf/facet_exec
  srr_facet_exec_i::srr_facet_exec_i (
    IDL::traits< ::Hello_B_SRR::CCM_CORBA_Connector_Context>::ref_type context)
    : context_ (std::move (context))
  {
  }


  // generated from corba4ccm/templates/comp_exec/src/corba/exf/operation
  int32_t
  srr_facet_exec_i::op_B (
    int32_t in_l,
    const ::Hello::S1& s_in_l)
  {
    return
      this->context_->get_connection_srr_receptacle ()->op_B (
        in_l,
        s_in_l);
  }

  // generated from corba4ccm/templates/comp_exec/src/corba/exf/operation
  int32_t
  srr_facet_exec_i::op_A (
    int32_t in_l)
  {
    return
      this->context_->get_connection_srr_receptacle ()->op_A (
        in_l);
  }

  Hello_B_servant::Hello_B_servant (
    IDL::traits< ::Hello::B>::ref_type facet_executor) :
      facet_executor_ (std::move (facet_executor))
  {
  }

  // generated from exf4cc/templates/comp_exec/src/corba/exf/component_extra_impl

  void Hello_B_servant::_configuration_complete (
      const ::Components::ConfigValues& config)
  {
    // check for scheduling lane
    for (const Components::ConfigValue& cval : config)
    {
      if (cval.name () == CIAOX11::ExF::SCHEDULING_LANE_REF)
      {
        IDL::traits<CORBA::Object>::ref_type objref {};
        if (!(cval.value () >>= objref))
        {
          throw std::runtime_error ("failed to extract " +
                                    CIAOX11::ExF::SCHEDULING_LANE_REF +
                                    " for CORBA connector");
        }
        this->scheduling_lane_ =
            IDL::traits<CIAOX11::ExF::SchedulingLane>::narrow (objref);
      }
    }

    if (this->scheduling_lane_)
    {
      // Get scheduling settings
      CIAOX11::ExF::Priority def_prio {};
      CIAOX11::ExF::Deadline def_deadline {};
      if (CIAOX11::ExF::Util::get_exf_defaults (
              config, def_prio, def_deadline))
      {

        this->op_B_deadline_ = def_deadline;
        this->op_B_priority_ = def_prio;

        this->op_A_deadline_ = def_deadline;
        this->op_A_priority_ = def_prio;
      }

      // check for scheduling properties
      CIAOX11::ExF::Util::get_exf_settings (
          config,
          "op_B",
          this->op_B_priority_,
          this->op_B_deadline_);

      CIAOX11::ExF::Util::get_exf_settings (
          config,
          "op_A",
          this->op_A_priority_,
          this->op_A_deadline_);

    }
  }

  class Hello_B_Executor final
    : public CIAOX11::ExF::Impl::AMH_Executor
  {
  public:
    Hello_B_Executor (
        std::string event_id,
        Hello::ExF::B_RequestHandlerBase::ref_type&& rh,
        IDL::traits< ::Hello::B>::ref_type executor,
        CIAOX11::ExF::Priority prio,
        CIAOX11::ExF::Deadline dl)
      : CIAOX11::ExF::Impl::AMH_Executor (std::move (prio), std::move (dl))
      , event_id_ (std::move (event_id))
      , rh_ (std::move (rh))
      , executor_ (std::move (executor))
    {
    }

    virtual ~Hello_B_Executor () = default;

    const std::string& event_id () const noexcept(true) override
    { return event_id_; }

  protected:
    void execute_i () override
    {
      this->rh_->execute (this->executor_);
    }

    void finish_i () override
    {
      this->rh_->send_reply ();
    }

    void send_exception_i (const CORBA::Exception& ex) override
    {
      this->rh_->send_exception (ex);
    }

  private:
    std::string const event_id_;
    Hello::ExF::B_RequestHandlerBase::ref_type rh_ {};
    IDL::traits< ::Hello::B>::ref_type executor_ {};

    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    Hello_B_Executor();
    Hello_B_Executor(const Hello_B_Executor&) = delete;
    Hello_B_Executor(Hello_B_Executor&&) = delete;
    Hello_B_Executor& operator=(const Hello_B_Executor&) = delete;
    Hello_B_Executor& operator=(Hello_B_Executor&&) = delete;
    //@}
  };

  class Hello_A_Executor final
    : public CIAOX11::ExF::Impl::AMH_Executor
  {
  public:
    Hello_A_Executor (
        std::string event_id,
        Hello::ExF::A_RequestHandlerBase::ref_type&& rh,
        IDL::traits< ::Hello::A>::ref_type executor,
        CIAOX11::ExF::Priority prio,
        CIAOX11::ExF::Deadline dl)
      : CIAOX11::ExF::Impl::AMH_Executor (std::move (prio), std::move (dl))
      , event_id_ (std::move (event_id))
      , rh_ (std::move (rh))
      , executor_ (std::move (executor))
    {
    }

    virtual ~Hello_A_Executor () = default;

    const std::string& event_id () const noexcept(true) override
    { return event_id_; }

  protected:
    void execute_i () override
    {
      this->rh_->execute (this->executor_);
    }

    void finish_i () override
    {
      this->rh_->send_reply ();
    }

    void send_exception_i (const CORBA::Exception& ex) override
    {
      this->rh_->send_exception (ex);
    }

  private:
    std::string const event_id_;
    Hello::ExF::A_RequestHandlerBase::ref_type rh_ {};
    IDL::traits< ::Hello::A>::ref_type executor_ {};

    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    Hello_A_Executor();
    Hello_A_Executor(const Hello_A_Executor&) = delete;
    Hello_A_Executor(Hello_A_Executor&&) = delete;
    Hello_A_Executor& operator=(const Hello_A_Executor&) = delete;
    Hello_A_Executor& operator=(Hello_A_Executor&&) = delete;
    //@}
  };

  // generated from exf4cc/templates/comp_exec/src/corba/exf/svnt_operation
  void
  Hello_B_servant::op_B (
      Hello::ExF::B_op_B_RequestHandler::ref_type rh)
  {
    CIAOX11::ExF::Executor::ref_type exec =
        std::make_unique<Hello_B_Executor> (
            "op_B",
            std::move (rh),
            this->facet_executor_,
            this->op_B_priority_,
            this->op_B_deadline_);

    this->scheduling_lane_->submit (std::move (exec));
  }

  // generated from exf4cc/templates/comp_exec/src/corba/exf/svnt_operation
  void
  Hello_B_servant::op_A (
      Hello::ExF::A_op_A_RequestHandler::ref_type rh)
  {
    CIAOX11::ExF::Executor::ref_type exec =
        std::make_unique<Hello_A_Executor> (
            "op_A",
            std::move (rh),
            this->facet_executor_,
            this->op_A_priority_,
            this->op_A_deadline_);

    this->scheduling_lane_->submit (std::move (exec));
  }



  // generated from exf4cc/templates/comp_exec/src/corba/exf/component_factory
  typedef CCM_CORBA::CORBA_Connector_T<
    ::Hello_B_SRR::CCM_CORBA_Connector,
    ::Hello_B_SRR::CCM_CORBA_Connector_Context,
    ::Hello::CCM_B,
    Hello_B_SRR_CORBA_Connector_Impl::srr_facet_exec_i,
    ::Hello::B,
    Hello_B_servant>
      Hello_B_CorbaConnector;

  namespace ExF
  {
    class Hello_B_CorbaConnector final
      : public Hello_B_SRR_CORBA_Connector_Impl::Hello_B_CorbaConnector
    {
    public:
      typedef Hello_B_SRR_CORBA_Connector_Impl::Hello_B_CorbaConnector base_type;

      Hello_B_CorbaConnector () = default;
      virtual ~Hello_B_CorbaConnector () = default;

      /// @copydoc Components::SessionComponent::configuration_complete
      void configuration_complete () override;

    private:
      /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
      //@{
      Hello_B_CorbaConnector(Hello_B_CorbaConnector&) = delete;
      Hello_B_CorbaConnector(Hello_B_CorbaConnector&&) = delete;
      Hello_B_CorbaConnector& operator=(Hello_B_CorbaConnector&) = delete;
      Hello_B_CorbaConnector& operator=(Hello_B_CorbaConnector&&) = delete;
      //@}
    };

    void
    Hello_B_CorbaConnector::configuration_complete ()
    {
      // first call base
      this->base_type::configuration_complete ();
      // now find Facet servant reference
      IDL::traits<PortableServer::POA>::ref_type poa =
          CCM_CORBA::get_corba4ccm_POA (this->context_);
      if (poa)
      {
        CORBA::servant_reference<PortableServer::Servant> svt_ref =
          CCM_CORBA::get_corba4ccm_facet (poa,
                                          this->context_->instance_id (),
                                          sync_request_reply_facet);

        CORBA::servant_traits< Hello_B_servant>::ref_type facet_svt_ref =
          CORBA::servant_traits< Hello_B_servant >::narrow (svt_ref);
        if (facet_svt_ref)
        {
          ::Components::ConfigValues facet_config (this->context_->srr_receptacle_configuration ());
          facet_svt_ref->_configuration_complete (facet_config);
          return;
        }
      }

      throw std::runtime_error (
          "failed to handle configuration_complete for CORBA connector");
    }
  }

} // namespace Hello_B_SRR_CORBA_Connector_Impl

extern "C" void
create_Hello_B_SRR_CORBA_Connector_Impl (
  IDL::traits<Components::EnterpriseComponent>::ref_type& component)
{
  component = CORBA::make_reference < Hello_B_SRR_CORBA_Connector_Impl::ExF::Hello_B_CorbaConnector> ();
}

// -*- END -*-
