include::_{backend}_settings.adoc[]

= APC
:linkattrs:

This document describes the options and features of the BRIX11 AXCIOMA Project Control(APC) tools.

== Introduction

The BRIX11 AXCIOMA Project Control (APC) tools are a set of link:{docs_root}/brix11/brix11.html[BRIX11]
command extensions with the intent of providing simplified and consistent project management for
AXCIOMA based application development.

APC removes the need of handcrafting link:{docs_root}/../../ACE/MPC/docs/html/MakeProjectCreator.html[MPC] files
for generating development tool specific project files (GNU make files, MSVC solution files etc.).

APC defines the concept of recipes to capture the user supplied meta information which in combination with
IDL files and executor/business code determines the end products (to be) built for an AXCIOMA project. APC's
tight integration with AXCIOMA as well as it's built-in capability to parse and analyze user defined
IDL files made it possible to have a far simpler and easier to understand syntax for APC recipes than for
MPC files.

An APC based project is assumed to be stored in a directory tree with a single common root.
This root is marked by the existence of a <<Project recipe file,project recipe file>>
stored at that location using a fixed name (`aprc`). +
The APC commands will always search back through their path from the working directory where the command is
executed to locate the root of the project tree. APC commands can therefor always be
executed anywhere from the project's directory tree.

APC defines various recipe types for different application products like connectors, components and basic (data) types.
<<Application recipes,Recipes>> are stored in text files using APC DSL (Domain Specific Language) definitions. +
A recipe file can have any name ending with a fixed extension (`.aprc`) and can be stored in any folder under the project
root folder.

Recipes for basic (data) types are optional. APC automatically creates implicit recipes if it detects that an IDL file is
referenced in the project (either by direct reference from an explicit recipe or by reference from one or more other IDL
files used in the project). Implicit recipes are transient and are not stored on disk.

A single recipe file can contain zero or more recipe definitions. A single project folder can contain zero or more recipe
files except for the root folder that must always contain the unique <<Project recipe file,project recipe file>>.

A typical (and minimal) AXCIOMA APC project structure could look like this:
----
>-[] <project root>
   |-aprc
   >-[] base
   |  |-data.idl
   >-[] connectors
   |  |-fooconn.aprc
   >-[] components
      >-[] sender
      |  |-sender.aprc
      |  |-sender_exec.h
      |  |-sender_exec.cpp
      >-[] receiver
         |-receiver.aprc
         |-receiver_exec.h
         |-receiver_exec.cpp
----

This document describes the most important options and commands which you need to learn how to use BRIX11 APC.

== Usage of APC

The following commands are implemented:

`brix11 apc prepare [options] [-- [mwc_options]]`::
This generates  with the use of recipes all projectfiles for a project.

`brix11 apc make [options]`::
This command builds the application products by running the project type specific build tools which drives source
compilation and linking.

`brix11 apc clean [options]`::
This command removes all intermediate artifacts (directories and files) generated by the `brix11 apc prepare` command
and any following `brix11 apc make` command.

Use the `-h` option available for each command to get detailed usage information about the commands.

The `brix11` command executable can be found in the `bin` directory of the package root
(typically `taox11_<version>/bin`). If you want to use `brix11` without
having to specify the full path you could add the `bin` directory to
your path (see <<{parent_dir}/brix11/brix11.adoc#,here>> for more information about BRIX11 in general).


=== APC prepare

To run APC in order to generate all makefiles for a project execute the following command anywhere from the project's directory tree:

`brix11 apc prepare`

The most important options are:

`brix11 apc prepare -m`::
 With the option `-m`, the link:{docs_root}/../../ACE/MPC/docs/html/MakeProjectCreator.html[MPC] files
 that APC generates as temporary, intermediate, products to generate the project's build files (make files, MSVC solution files etc.)
 are not removed after the projectfiles are generated. By default, without this option, the
 temporary MPC files are deleted after the projectfiles are generated.

`brix11 apc prepare -h`::
 This displays usage information with an overview of the general options.

=== APC make

To have APC run the project type specific build tool for the entire project execute the following command anywhere from the project's directory tree:

`brix11 apc make`

The most important options are:

`brix11 apc make -r`::
 With the option `-r` APC will first run the build tool in _cleanup_ mode which will remove all compilation and linking
 artifacts (but not the project/build files) before running the build tool in _make_ mode effectively rebuilding the entire
 project.

`brix11 apc make -h`::
 This displays usage information with an overview of the general options.

=== APC clean

To run APC in order to remove all intermediate artifacts (directories and files) generated by the 'axp prepare' command
and any following `brix11 make` command execute the following command anywhere from the project's directory tree:

`brix11 apc clean`

This command will also remove any of the MPC files created by an `apc prepare` command with the `-m` switch added.

== Recipe files

An APC based project contains one <<Project recipe,project recipe file>> and one or more
<<Application recipes,application recipe files>> where the recipes for the application products are defined.

=== Recipe syntax

BRIX11 has been created using the link:https://www.ruby-lang.org[Ruby] programming language and the APC recipe DSL has been
designed as executable Ruby code following the Ruby language syntax. You can find detailed information about the language
and how to create programs with it link:http://www.ruby-doc.org/docs/ProgrammingRuby[here] (more documentation can be found
link:https://www.ruby-lang.org/en/documentation[here]).

For APC recipe DSL the most important syntax rules are described below.

Comments::
Lines starting with `#` are considered comments and are not parsed or interpreted.

Recipe definitions::
Recipes define properties for a single type of APC recipe object. The type of recipe object is identified by a keyword like `component`,
`connector` or `base` followed by an identifier and a scope block with a single argument representing the object being defined.
+
[source, ruby]
.Component recipe example
----
component 'shapes_sender' do |comp|
  comp.idl %w{shapes_sender_comp.idl}
end
----
+
The identifier (`'shapes_sender'` in this example) should be a <<Value type declarations,string>> and must be unique
within the scope of a single recipe file. +
A reference to the recipe object is passed as the single argument which can be assigned any valid variable name
(in this example `comp`). +
+
A <<Project recipe file,project recipe file>> always contains the property definitions for a single recipe object, the
implicit Project recipe. The keyword, identifier and scoping delimiters are implicit in this case and should not (can not) be specified.
The single recipe object reference variable is implicitly named `prj` allowing to define project properties with statements like
`prj.idl_includes %w{...}`.

Property definitions::
Property definitions for APC recipes are proper Ruby expressions which are best put on separate lines (Ruby allows
concatenation of multiple expressions on a single line by separation with the `;` but this will affect the clearity
of the recipe definitions). +
Each property expression follows the following generic format; `<recipe>.<property> <definition>` where +
+
[horizontal]
<recipe>::: is the variable name specified for the single argument to the recipe scope block
<property>::: is any valid property name for the recipe being defined
<definition>::: is any valid property argument or assignment expression for the property being defined

=== Project recipe

An APC based project is assumed to be stored in a directory tree with a single common root.This root is
marked by the existence of a project recipe file stored at that location using a fixed name (`aprc`) which
contains a single recipe definition.
The project recipe specifies the common project properties such as directories where the data and
interface idl files are located.

Properties::
[footnote]#xref:prj-includes[icon:caret-right[]{nbsp}{nbsp}includes]# +
[footnote]#xref:prj-idl_includes[icon:caret-right[]{nbsp}{nbsp}idl_includes]# +
[footnote]#xref:prj-libout[icon:caret-right[]{nbsp}{nbsp}libout]# +
[footnote]#xref:prj-libpaths[icon:caret-right[]{nbsp}{nbsp}libpaths]# +
[footnote]#xref:prj-libs[icon:caret-right[]{nbsp}{nbsp}libs]# +
[footnote]#xref:prj-lit_libs[icon:caret-right[]{nbsp}{nbsp}lit_libs]#

[cols="<2m,<8a",options="header",]
|=======================================================================
|Property |

|[[prj-includes]]includes
|
Description::
Specifies additional include paths to be passed on to the pass:[C++]
compiler. Each path specified either as absolute path or relative to the location
of the file in which the recipe is declared. Can be declared multiple
times.
Syntax::
_rcp_.includes <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
prj.includes %w{$(ACE_ROOT)/protocols}
----

|[[prj-idl_includes]]idl_includes
|
Description::
Specifies additional IDL include paths to be passed on to
the IDL compiler. Specified either as absolute path or relative to the
location of the file in which the recipe is declared. Can be declared
multiple times.
Syntax::
_rcp_.idl_includes <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
prj.idl_includes %w{../data comp_data}
----

|[[prj-libout]]libout
|
Description::
Specifies the output path for generated libs. Default is 'lib'
Syntax::
_rcp_.libout <<<Value type declarations,string>>>

[source, ruby]
.example
----
prj.libout 'my_lib'
----

|[[prj-libpaths]]libpaths
|
Description::
Specifies additional library lookup paths to be passed on to
the C++ linker. Specified either as absolute path or relative to the
location of the file in which the recipe is declared. Can be declared
multiple times.
Syntax::
_rcp_.libpaths <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
prj.libpaths %w{testlib/mylib $(ACE_ROOT)/protocols/ace/INet}
----

|[[prj-libs]]libs
|
Description::
Specifies additional library base names (i.e. undecorated) of
libraries to be passed on to the C++ linker. Can be declared multiple
times.
Syntax::
_rcp_.libs <<<Value type declarations,stringlist>>>

[source, ruby]
.example
----
prj.libs %w{ACE_INet}
----

|[[prj-lit_libs]]lit_libs
|
Description::
Specifies additional library names (i.e. fully decorated
except for extension) of libraries to be passed on to the C++ linker.
Can be declared multiple times.
Syntax::
_rcp_.lit_libs <<<Value type declarations,stringlist>>>

[source, ruby]
.example
----
prj.lit_libs %w{my_lit_lib}
----

|=======================================================================

An APC Project recipe file could look like the example shown next.

[source,ruby]
.aprc (example project recipe file)
--------------------------
# Project: test
# Author: A User

# look for IDL files at least in <project root>/data and <project root>/common
prj.idl_includes %w{data common}

# store created library files in <project root>/libraries
prj.libout 'libraries'
--------------------------

=== Application recipes

APC defines various recipe types for different application products like
<<Component recipe,components>>, <<Connector recipe,connectors>> and <<Base recipe,data>>. Product recipes are stored
in text files using APC DSL (Domain Specific Language) definitions. A
recipe file can have any name ending with a fixed extension (`.aprc`).
An application recipe file can contain zero or more of the following recipe definitions:

[square]
* `component` recipe
* `connector` recipe
* `base` recipe

==== Component recipe

An APC `component` recipe specifies the property settings from which APC can generate the appropriate project files
(make files or MSVC solution files as per your setup) and optionally the component IDL file.

APC `component` recipes can either be specified for user defined component IDL files or to create the component IDL file
based on a component interface definition added to the recipe.

With a user defined component IDL the recipe definition needs to specify name and location of the file and then APC
will analyze the IDL file to determine the requirements of the component (which type of ports are used).

In case the `component` recipe is extended with an interface definition, APC will determine component requirements from that
and generate the component IDL file automatically.

A minimum `component` recipe where the component interface is defined in a user defined IDL file could look like:

[source, ruby]
.example of component recipe with user defined component IDL
----
component 'shapes_sender' do |comp|
  comp.idl %w{ shapes_sender_comp.idl }
end
----

APC will analyze the contents of the `shapes_sender_comp.idl` to determine the requirements for the project files to
generate.

A minimum `component` recipe with a component interface definition could look like:

[source, ruby]
.example of component recipe with component interface definition
----
component 'foo_sender' do |comp|
  comp.idl %w{ foo.idl }
  comp.define 'Test::Sender' do |intf|
    intf.port 'run_my_foo' do |port|
      port.uses 'Foo'
    end
  end
end
----

APC will generate a component IDL file named `foo_sender.idl` with a component `Sender` in module `Test` with a
receptacle definition (`uses`) for interface `Foo` (which should be defined in file `foo.idl`) named `run_my_foo`.
Furthermore APC will generated all required project files according to the requirements of the interface definition.

===== Basic properties

The following properties can be used to define a `component` recipe. If a property is not mandatory it can be omitted in
which case the default applies.

[none]
* [footnote]#xref:comp-idl[icon:caret-right[]{nbsp}{nbsp}idl]#
* [footnote]#xref:comp-export_name[icon:caret-right[]{nbsp}{nbsp}export_name]#
* [footnote]#xref:comp-shared_name[icon:caret-right[]{nbsp}{nbsp}shared_name]#
* [footnote]#xref:comp-combined_lib[icon:caret-right[]{nbsp}{nbsp}combined_lib]#
* [footnote]#xref:comp-includes[icon:caret-right[]{nbsp}{nbsp}includes]#
* [footnote]#xref:comp-idl_includes[icon:caret-right[]{nbsp}{nbsp}idl_includes]#
* [footnote]#xref:comp-gen_dir[icon:caret-right[]{nbsp}{nbsp}gen_dir]#
* [footnote]#xref:comp-sources[icon:caret-right[]{nbsp}{nbsp}sources]#
* [footnote]#xref:comp-base_projects[icon:caret-right[]{nbsp}{nbsp}base_projects]#
* [footnote]#xref:comp-libpaths[icon:caret-right[]{nbsp}{nbsp}libpaths]#
* [footnote]#xref:comp-libs[icon:caret-right[]{nbsp}{nbsp}libs]#
* [footnote]#xref:comp-lit_libs[icon:caret-right[]{nbsp}{nbsp}lit_libs]#
* [footnote]#xref:comp-define[icon:caret-right[]{nbsp}{nbsp}define]#

[cols="<2m,<8a",options="header"]
|=======================================================================

|Property|

|[[comp-idl]]idl
|
Description::
Specifies the IDL file(s) used for the recipe. Specified either as
absolute path or relative to the location of the file in which the
recipe is declared. In case no component interface is defined a single IDL file specification
through the idl property is expected which should contain the user supplied component
IDL declaration.
Otherwise, when a component interface is defined the idl property is expected to specify
the required IDL files declaring data and/or interface types needed by the component.
This property is mandatory.
Syntax::
rcp.idl <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.idl 'shapes_sender_comp.idl'
  # ...
end
----

|[[comp-export_name]]export_name
|
Description::
Specifies the basename used for generated export macros.
By default the recipe_id is used as base name.
Syntax::
rcp.export_name <<<Value type declarations,string>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.export_name 'my_export_sender'
  # ...
end
----

|[[comp-shared_name]]shared_name
|
Description::
Specifies the basename used for creating shared libraries. By
default the recipe_id is used as base name.
Syntax::
rcp.shared_name <<<Value type declarations,string>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.shared_name 'my_sender'
  # ...
end
----

|[[comp-combined_lib]]combined_lib
|
Description::
Specifies to create a single combined component library. +
By default the option is `false` and separate libraries are built for
stubs (if needed), lem, component servant and component executor.
Syntax::
rcp.combined_lib <boolean>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.combined_lib true
  # ...
end
----

|[[comp-includes]]includes
|
Description::
Specifies additional include paths to be passed on to the C++
compiler. Specified either as absolute path or relative to the location
of the file in which the recipe is declared. Can be declared multiple
times.
Syntax::
rcp.includes <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.includes '../test', '$(ACE_ROOT)/protocols'
  # ...
end
----

|[[comp-idl_includes]]idl_includes
|
Description::
Specifies additional IDL include paths to be passed on to
the IDL compiler. Specified either as absolute path or relative to the
location of the file in which the recipe is declared. Can be declared
multiple times.
Syntax::
rcp.idl_includes <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.idl_includes %w{../data comp_data}
  # ...
end
----

|[[comp-gen_dir]]gen_dir
|
Description::
Specifies the output path for generated code (by the IDL
compiler). Default is 'generated_code'
Syntax::
rcp.gen_dir <<<Value type declarations,string>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.gen_dir 'build'
  # ...
end
----

|[[comp-sources]]sources
|
Description::
Specifies additional C++ source code files to be included in
the component's executor library. Specified either as absolute path or
relative to the location of the file in which the recipe is declared.
Can be declared multiple times.
Syntax::
rcp.sources <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.sources %w{test.cpp}
  # ...
end
----

|[[comp-base_projects]]base_projects
|
Description::
Specifies the MPC base projects for the component
executor library. Allows to add or remove strings. By default the list
can contain any number of, optional, system defined base project names.
Can be declared multiple times.
Syntax::
rcp.base_projects += <<<Value type declarations,stringlist>>> +
*or* +
rcp.base_projects -= <<<Value type declarations,stringlist>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.base_projects += 'taox11_anytypecode'
  comp.base_projects -= 'ciaox11_logger'
  # ...
end
----

|[[comp-libpaths]]libpaths
|
Description::
Specifies additional library lookup paths to be passed on to
the C++ linker. Specified either as absolute path or relative to the
location of the file in which the recipe is declared. Can be declared
multiple times.
Syntax::
rcp.libpaths<<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.libpaths ['../../testlib', '$(ACE_ROOT)/protocols/ace/INet']
  # ...
end
----

|[[comp-libs]]libs
|
Description::
Specifies additional library base names (i.e. undecorated) of
libraries to be passed on to the C++ linker. Can be declared multiple
times.
Syntax::
rcp.libs <<<Value type declarations,stringlist>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.libs %w{ ACE_INet MyLib}
  # ...
end
----

|[[comp-lit_libs]]lit_libs
|
Description::
Specifies additional library names (i.e. fully decorated
except for extension) of libraries to be passed on to the C++ linker.
Can be declared multiple times.
Syntax::
rcp.lit_libs <<<Value type declarations,stringlist>>>

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.lit_libs %w{my_lit_lib}
  # ...
end
----

|[[comp-define]]define
|
Description::
Defines the component IDL interface to be generated. Can be declared only once or omitted.
Syntax::
rcp.define <<<Value type declarations,string>>> do <component interface spec> end

[source, ruby]
.example
----
component 'my_component' do \|comp\|
  # ...
  comp.define 'Module::Sender' do \|intf\|
    # ...
  end
  # ...
end
----

|=======================================================================

===== Interface definition

When defining a component interface as part of the component recipe (with the `comp.define <interface> do ... end` construct)
the following properties are available for the interface being defined.

Properties::
[footnote]#xref:comp-intf-port[icon:caret-right[]{nbsp}{nbsp}port]# +
[footnote]#xref:comp-intf-attribute[icon:caret-right[]{nbsp}{nbsp}attribute]#

[cols="<2m,<8a",options="header"]
|=======================================================================

|Property |

|[[comp-intf-port]]port
|
Description::
Defines a port
Syntax::
intf.port <<<Value type declarations,string>>> do \|port\| +
  <port spec> +
end +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, <port spec>

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'run_my_foo' do \|port\|
    port.uses 'Hello::MyFoo'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'run_my_foo', uses: 'Hello::MyFoo
end
----

|[[comp-intf-attribute]]attribute
|
Description::
Defines a attribute
Syntax::
intf.attribute <<<Value type declarations,string>>> do \|att\| +
  <attribute spec> +
end +
+
_or in condensed form:_ +
+
intf.attribute <<<Value type declarations,string>>>, <attribute spec>

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.attribute 'my_attrib' do \|att\|
    att.type 'short'
    att.readonly true
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.attribute 'my_attrib', type: 'short', readonly: true
end
----

|=======================================================================

===== Port definition

When defining a component interface port the following properties are available for the port being defined.
Each of these properties is mutually exclusive, i.e. a port definition can ever only have one of these properties
set.
Specifying a port property is required.

Properties::
[footnote]#xref:comp-port-uses[icon:caret-right[]{nbsp}{nbsp}uses]# +
[footnote]#xref:comp-port-provides[icon:caret-right[]{nbsp}{nbsp}provides]# +
[footnote]#xref:comp-port-sends[icon:caret-right[]{nbsp}{nbsp}sends]# +
[footnote]#xref:comp-port-writes[icon:caret-right[]{nbsp}{nbsp}writes]# +
[footnote]#xref:comp-port-updates[icon:caret-right[]{nbsp}{nbsp}updates]# +
[footnote]#xref:comp-port-reads[icon:caret-right[]{nbsp}{nbsp}reads]# +
[footnote]#xref:comp-port-gets[icon:caret-right[]{nbsp}{nbsp}gets]# +
[footnote]#xref:comp-port-monitors[icon:caret-right[]{nbsp}{nbsp}monitors]# +
[footnote]#xref:comp-port-observes[icon:caret-right[]{nbsp}{nbsp}observes]# +
include::{ciaox11_src_root}/connectors/psdd4ccm/docs/src/axcioma_project_tool.asc[tag=pubsubporttype,opts=optional]
[footnote]#xref:comp-port-timed_trigger[icon:caret-right[]{nbsp}{nbsp}timed_trigger]#

[cols="<2m,<8a",options="header"]
|=======================================================================

|Property |

|[[comp-port-uses]]uses
|
Description::
Defines a synchronous (multiplex) receptacle for the interface type specified as argument. +
The IDL interface type specified should reference a valid IDL defined `interface` type.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.uses <<<Value type declarations,string>>> +
_or_ +
port.uses <<<Value type declarations,string>>>, multiple: true +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, uses: <<<Value type declarations,string>>> +
_or_ +
intf.port <<<Value type declarations,string>>>, uses: [<<<Value type declarations,string>>>, multiple: true]

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.uses 'Hello::MyFoo'
  end
end
----

[source, ruby]
.multiplex example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.uses 'Hello::MyFoo', multiple: true
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port', uses: 'Hello::MyFoo'
end
----

[source, ruby]
.multiplex example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port', uses: ['Hello::MyFoo', multiple: true]
end
----

|[[comp-port-provides]]provides
|
Description::
Defines a facet for the interface type specified as argument. +
The IDL interface type specified should reference a valid IDL defined `interface` type.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.provides <<<Value type declarations,string>>> +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, provides: <<<Value type declarations,string>>>

[source, ruby]
.example, block form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.provides 'Hello::MyFoo'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port', provides: 'Hello::MyFoo'
end
----

|[[comp-port-sends]]sends
|
Description::
Defines an asynchronous (multiplex) receptacle for the interface type specified as argument. +
The IDL interface type specified should reference a valid IDL defined `interface` type.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.sends <<<Value type declarations,string>>> +
_or_ +
port.sends <<<Value type declarations,string>>>, multiple: true +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, sends: <<<Value type declarations,string>>> +
_or_ +
intf.port <<<Value type declarations,string>>>, sends: [<<<Value type declarations,string>>>, multiple: true]

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.sends 'Hello::MyFoo'
  end
end
----

[source, ruby]
.multiplex example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.sends 'Hello::MyFoo', multiple: true
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port', sends: 'Hello::MyFoo'
end
----

[source, ruby]
.multiplex example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port', sends: ['Hello::MyFoo', multiple: true]
end
----

|[[comp-port-writes]]writes
|
Description::
Defines a writer port for the topic type specified as argument. +
The IDL type specified should conform to the DDS4CCM specification for port topic types.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.writes <<<Value type declarations,string>>> +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, writes: <<<Value type declarations,string>>>

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.writes 'Test::Shape'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port', writes: 'Test::Shape'
end
----

|[[comp-port-updates]]updates
|
Description::
Defines an updater port for the topic type specified as argument. +
The IDL type specified should conform to the DDS4CCM specification for port topic types.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.updates <<<Value type declarations,string>>> +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, updates: <<<Value type declarations,string>>>

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.updates 'Test::Shape'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port', updates: 'Test::Shape'
end
----

|[[comp-port-reads]]reads
|
Description::
Defines a reader port for the topic type specified as argument. +
The IDL type specified should conform to the DDS4CCM specification for port topic types.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.reads <<<Value type declarations,string>>> +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, reads: <<<Value type declarations,string>>>

[source, ruby]
.example, block form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.reads 'Test::Shape'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port', reads: 'Test::Shape'
end
----

|[[comp-port-gets]]gets
|
Description::
Defines a getter port for the topic type specified as argument. +
The IDL type specified should conform to the DDS4CCM specification for port topic types.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.gets <<<Value type declarations,string>>> +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, gets: <<<Value type declarations,string>>>

[source, ruby]
.example, block form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.gets 'Test::Shape'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port', gets: 'Test::Shape'
end
----

|[[comp-port-monitors]]monitors
|
Description::
Defines a listener port for the topic type specified as argument. +
The IDL type specified should conform to the DDS4CCM specification for port topic types.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.monitors <<<Value type declarations,string>>> +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, monitors: <<<Value type declarations,string>>>

[source, ruby]
.example, block form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.monitors 'Test::Shape'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port', monitors: 'Test::Shape'
end
----

|[[comp-port-observes]]observes
|
Description::
Defines a state listener port for the topic type specified as argument. +
The IDL type specified should conform to the DDS4CCM specification for port topic types.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
port.observes <<<Value type declarations,string>>> +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, observes: <<<Value type declarations,string>>>

[source, ruby]
.example, block form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.observes 'Test::Shape'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Receiver' do \|intf\|
  intf.port 'my_port', observes: 'Test::Shape'
end
----

include::{ciaox11_src_root}/connectors/psdd4ccm/docs/src/axcioma_project_tool.asc[tag=porttype,opts=optional]

|[[comp-port-timed_trigger]]timed_trigger
|
Description::
Defines a Timed Trigger scheduler port.
Syntax::
port.timed_trigger +
+
_or in condensed form:_ +
+
intf.port <<<Value type declarations,string>>>, :timed_trigger

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port' do \|port\|
    port.timed_trigger
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.port 'my_port', :timed_trigger
end
----

*NOTE*: _unlike the other port types a `timed_trigger` port does not require building
a matching user defined connector implementation as the `timed_trigger` port implements
an AXCIOMA standard interface and a matching connector implementation is included into
the distribution by default_

|=======================================================================

===== Attribute definition

When defining a component interface attribute the following properties are available for the attribute being defined.

Properties::

[footnote]#xref:comp-attrib-type[icon:caret-right[]{nbsp}{nbsp}type]# +
[footnote]#xref:comp-attrib-readonly[icon:caret-right[]{nbsp}{nbsp}readonly]#

[cols="<2m,<8a",options="header"]
|=====================================================================

|Property |

|[[comp-attrib-type]]type
|
Description::
Defines the IDL type of the attribute. This property is mandatory. +
The IDL type specified should conform to the LwCCM specification for component attribute types.
For user defined IDL types the IDL compiler needs to be able to resolve the type through default
includes and/or the IDL files specified for the component recipe's `idl` property. Scoped IDL
typenames are supported.
Syntax::
att.type <<<Value type declarations,string>>> +
+
_or in condensed form:_ +
+
intf.attribute <<<Value type declarations,string>>>, type: <<<Value type declarations,string>>>

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.attribute 'my_attrib' do \|att\|
    att.type 'short'
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.attribute 'my_attrib', type: 'short'
end
----

|[[comp-attrib-readonly]]readonly
|
Description::
Defines the mutability of the attribute.
This property is optional. By default the readonly property is false.
Syntax::
port.readonly <boolean> +
+
_or in condensed form:_ +
+
intf.attribute <<<Value type declarations,string>>>, type: <<<Value type declarations,string>>>, readonly: true

[source, ruby]
.example, block form
----
comp.define 'Module::Sender' do \|intf\|
  intf.attribute 'my_attrib' do \|att\|
    att.type 'short'
    att.readonly true
  end
end
----

[source, ruby]
.example, condensed form
----
comp.define 'Module::Sender' do \|intf\|
  intf.attribute 'my_attrib', type: 'short', readonly: true
end
----

|=====================================================================

==== Connector recipe

An APC `connector` recipe specifies the property settings from which APC can generate the appropriate project files
(make files or MSVC solution files as per your setup) and the connector IDL file from which to fully generate the
connector implementation (no user coding required).

A minimum `connector` recipe for a synchronous CORBA request-reply connector providing a user defined IDL interface could look like:

[source, ruby]
.minimum CORBA connector example
----
connector 'control_conn' do |conn|
  conn.idl %w{ control_obj.idl }
  conn.port_type :corba4ccm
end
----

The APC project tool generates (a) complete CORBA connector implementation(s) from this recipe basing generated project file
and connector IDL file names on the recipe_id `control_conn` and referencing the specified IDL file `control_obj.idl` to determine
the `interface`s for which to provide implementations for (for each interface encountered in the specified IDL file a complete
connector implementation is generated).

At the moment APC supports the following kinds of connectors:

[none]
* `_:corba4ccm_` +
for synchronous request-reply interaction
* `_:ami4ccm_` +
for asynchronous request-reply interaction
* `_:dds4ccm_` +
for state and event interaction
include::{ciaox11_src_root}/connectors/psdd4ccm/docs/src/axcioma_project_tool.asc[tag=connectorkind,opts=optional]

The following properties can be used to define a `connector` recipe. If a property is not mandatory it can be omitted in
which case the default applies.

===== Basic properties

[no-bullet]
* [footnote]#xref:conn-idl[icon:caret-right[]{nbsp}{nbsp}idl]#
* [footnote]#xref:conn-idl_includes[icon:caret-right[]{nbsp}{nbsp}idl_includes]#
* [footnote]#xref:conn-port_type[icon:caret-right[]{nbsp}{nbsp}port_type]#
* [footnote]#xref:conn-export_name[icon:caret-right[]{nbsp}{nbsp}export_name]#
* [footnote]#xref:conn-shared_name[icon:caret-right[]{nbsp}{nbsp}shared_name]#
* [footnote]#xref:conn-gen_dir[icon:caret-right[]{nbsp}{nbsp}gen_dir]#
include::{ciaox11_src_root}/exf/docs/src/axcioma_project_tool.asc[tag=basicproperties,opts=optional]

[cols="<2m,<8a",options="header"]
|=======================================================================
|Property |

|[[conn-idl]]idl
|
Description::
Specifies the IDL file(s) for the recipe. The(se) IDL file(s) should define the type(s)
which the connector port(s) should be implemented for. +
Specified either as absolute path or relative to the location of the file in which the
recipe is declared. Can be declared multiple times. This property is mandatory.
Syntax::
rcp.idl <<<Value type declarations,pathlist>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.idl %w\{ shapes_shapetype_msg.idl }
  # ...
end
----

|[[conn-idl_includes]]idl_includes
|
Description::
Specifies additional IDL include paths to be passed on to
the IDL compiler. Specified either as absolute path or relative to the
location of the file in which the recipe is declared. Can be declared
multiple times.
Rarely needed as normally the IDL include directories defined in the project
recipe suffice.
Syntax::
rcp.idl_includes <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
connector 'my_conn' do \|conn\|
  # ...
  conn.idl %w\{ shapes_shapetype_msg.idl }
  conn.idl_includes %w{../data}
  # ...
end
----

|[[conn-port_type]]port_type
|
Description::
Specifies the type of the connector. This property is mandatory.
Syntax::
rcp.port_type <<<Value type declarations,symbol>>> +
+
possible <port type> values:::
* `:corba4ccm`
* `:ami4ccm`
* `:dds4ccm`
include::{ciaox11_src_root}/connectors/psdd4ccm/docs/src/axcioma_project_tool.asc[tag=porttypelist,opts=optional]

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :ami4ccm
  # ...
end
----

|[[conn-export_name]]export_name
|
Description::
Specifies the basename used for generated export macros.
By default the recipe_id is used as base name.
Syntax::
rcp.export_name <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.export_name 'my_myfoo'
  # ...
end
----

|[[conn-shared_name]]shared_name
|
Description::
Specifies the basename used for creating shared libraries. By
default the recipe_id is used as base name.
Syntax::
rcp.shared_name <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.shared_name 'my_conn'
  # ...
end
----

|[[conn-gen_dir]]gen_dir
|
Description::
Specifies the output path for generated code (by the IDL
compiler). Default is 'generated_code'
Syntax::
rcp.gen_dir <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.gen_dir 'conn_dir_build'
  # ...
end
----

include::{ciaox11_src_root}/exf/docs/src/axcioma_project_tool.asc[tag=exfproperty,opts=optional]

|=======================================================================

===== Port Type definitions


For _CORBA4CCM_ and _AMI4CCM_ connector types the following additional port type property specification is
possible.

====== *:corba4ccm* and *:ami4ccm*

[none]
* [footnote]#xref:conn-port-interface[icon:caret-right[]{nbsp}{nbsp}interface]#

[cols="<2m,<8a",options="header"]
|=======================================================================
|Property |

|[[conn-port-interface]]interface
|
Description::
Specifies the scoped IDL typename of the IDL
defined `interface` type (from the IDL file specified by the 'idl' property) for
which the connector implementation is intended. +
If this property is not specified connector implementations will be generated for
every matching (non-local, non-abstract and, in the case of _AMI4CCM_, annotated for AMI)
`interface` definition in the specified IDL files.
Syntax::
port.interface <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :corba4ccm do \|tp\|
    tp.interface  'Hello::Foo'
  end
  # ...
end
----

|=======================================================================

====== *:dds4ccm*

[none]
* [footnote]#xref:conn-port-topic[icon:caret-right[]{nbsp}{nbsp}topic]#
* [footnote]#xref:conn-port-middleware[icon:caret-right[]{nbsp}{nbsp}middleware]#
* [footnote]#xref:conn-port-topic_namespace[icon:caret-right[]{nbsp}{nbsp}topic_namespace]#
* [footnote]#xref:conn-port-topic_sequence_suffix[icon:caret-right[]{nbsp}{nbsp}topic_sequence_suffix]#
* [footnote]#xref:conn-port-topic_sequence[icon:caret-right[]{nbsp}{nbsp}topic_sequence]#
* [footnote]#xref:conn-port-topic_interface_suffix[icon:caret-right[]{nbsp}{nbsp}topic_interface_suffix]#
* [footnote]#xref:conn-port-topic_interface[icon:caret-right[]{nbsp}{nbsp}topic_interface]#

For _DDS4CCM_ connector types the following additional port type property specification is
required.

[cols="<2m,<8a",options="header"]
|=======================================================================
|Property |

|[[conn-port-topic]]topic
|
Description::
Specifies the scoped IDL typename of the IDL
defined type (from the IDL file specified by the 'idl' property) for
which the State/Event or Pub/Sub interface is intended.  This property is mandatory.
Syntax::
port.topic <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :dds4ccm do \|tp\|
    tp.topic  'Hello::ShapeType'
  end
  # ...
end
----

|=======================================================================

.Single or Multiple Connector Implementations
****
Unlike for _CORBA4CCM_ and _AMI4CCM_ connector types, for _DDS4CCM_ connectors the specification
of a single type for the connector port is mandatory. As a result a connector recipe for a
_DDS4CCM_ connector will always result in a single connector implementation supporting only one topic type.
This in contrast with recipes for _CORBA4CCM_ and _AMI4CCM_ connectors where, without specific `interface`
type specification, APC will generate connector implementations for each matching interface type in
each IDL file specified.
****

For _DDS4CCM_ connector types the following additional, optional, port type property specifications are
possible.

[cols="<2m,<8a",options="header"]
|=======================================================================
|Property |

|[[conn-port-middleware]]middleware
|
Description::
Specifies the middleware to use for the connector implementation. +
DDS4CCM currently supports 'ndds' (default).
Syntax::
port.middleware <<<Value type declarations,stringlist>>> \| <<<Value type declarations,symbollist>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :dds4ccm do \|tp\|
    tp.topic  'Hello::ShapeType'
    tp.middleware :ndds  # currently default and only vendor
  end
  # ...
end
----

|[[conn-port-topic_namespace]]topic_namespace
|
Description::
Specifies the scoped IDL module name to use to enclose the topic sequence and topic
interface definitions in.
By default the definitions are enclosed in the same scope as the topic type.
Syntax::
port.topic <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :dd4ccm do \|tp\|
    tp.topic  'Hello::ShapeType'
    tp.topic_namespace 'Test'
  end
  # ...
end
----

|[[conn-port-topic_sequence_suffix]]topic_sequence_suffix
|
Description::
Specifies the suffix string used to derive the topic sequence type name from the
(unscoped) topic type name.
By default the suffix is `'Seq'`.
Syntax::
port.topic <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :dds4ccm do \|tp\|
    tp.topic  'Hello::ShapeType'
    tp.topic_sequence_suffix '_seq_t'
  end
  # ...
end
----

|[[conn-port-topic_sequence]]topic_sequence
|
Description::
Specifies the IDL typename to use for the topic sequence type.
By default the sequence type is named after the topic type with the suffix 'Seq' appended.
Syntax::
port.topic <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :dd4ccm do \|tp\|
    tp.topic  'Hello::ShapeType'
    tp.topic_sequence 'Shape_seq_t'
  end
  # ...
end
----

|[[conn-port-topic_interface_suffix]]topic_interface_suffix
|
Description::
Specifies the suffix string used to derive the topic interface module name from the
(unscoped) topic type name.
By default the suffix is `'Interface'`.
Syntax::
port.topic <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :dds4ccm do \|tp\|
    tp.topic  'Hello::ShapeType'
    tp.topic_interface_suffix '_interface'
  end
  # ...
end
----

|[[conn-port-topic_interface]]topic_interface
|
Description::
Specifies the IDL name to use for the topic interface module.
By default the interface module is named after the topic type with the suffix 'Interface' appended.
Specifies the scoped IDL typename of the IDL
defined type (from the IDL file specified by the 'idl' property) for
which the State/Event interface is intended.  This property is mandatory.
Syntax::
port.topic <<<Value type declarations,string>>>

.example
[source, ruby]
----
connector 'my_conn' do \|conn\|
  # ...
  conn.port_type :dd4ccm do \|tp\|
    tp.topic  'Hello::ShapeType'
    tp_interface 'IShape'
  end
  # ...
end
----

|=======================================================================

include::{ciaox11_src_root}/connectors/psdd4ccm/docs/src/axcioma_project_tool.asc[leveloffset=+4,tag=porttypeproperties,opts=optional]

==== Base recipe

An APC base recipe specifies the property settings from which APC can generate the appropriate project files
to generate the appropriate stubs and skeletons for the IDL file(s) specified for the recipe.

A minimum `base` recipe could look like:

[source, ruby]
.minimum base recipe
----
base 'my_data' do |dat|
   dat.idl %w{foo.idl}
end
----

Specifying `data` recipes is optional. In case no `data` recipe exists listing an IDL file referenced in other recipes
(either data, connector, component etc.) in the same project, APC will declare an implicit data recipe linked to
the folder in which the IDL file is stored. Any other IDL file in the same folder also referenced in the same project
will be added to the same implicit `base` recipe. +
IDL files generated through APC (or project files generated by APC) for connector and component definitions as well
as user defined component IDL files used in component recipes will be excluded from implicit `base` recipes.

The following properties can be used to define a `base` recipe. If a property is not mandatory it can be
omitted in which case the default applies.

Properties::
[none]
* [footnote]#xref:base-idl[icon:caret-right[]{nbsp}{nbsp}idl]#
* [footnote]#xref:base-includes[icon:caret-right[]{nbsp}{nbsp}includes]#
* [footnote]#xref:base-idl_includes[icon:caret-right[]{nbsp}{nbsp}idl_includes]#
* [footnote]#xref:base-gen_dir[icon:caret-right[]{nbsp}{nbsp}gen_dir]#
* [footnote]#xref:base-export_name[icon:caret-right[]{nbsp}{nbsp}export_name]#
* [footnote]#xref:base-shared_name[icon:caret-right[]{nbsp}{nbsp}shared_name]#

[cols="<2m,<8a",options="header"]
|=======================================================================
|Property |

|[[base-idl]]idl
|
Description::
Specifies the IDL file(s) used for the recipe. Specified either as
absolute path or relative to the location of the file in which the
recipe is declared. Can be declared multiple
times. +
This property is mandatory for any user defined `base` recipe.
Syntax::
rcp.idl <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
base 'my_data' do \|dat\|
  dat.idl %w{ shapes_sender_comp.idl }
end
----

|[[base-includes]]includes
|
Description::
Specifies additional include paths to be passed on to the C++
compiler. Specified either as absolute path or relative to the location
of the file in which the recipe is declared. Can be declared multiple
times.
Syntax::
rcp.includes <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
base 'my_data' do \|dat\|
  dat.includes %w{../test $(ACE_ROOT)/protocols}
end
----

|[[base-idl_includes]]idl_includes
|
Description::
Specifies additional IDL include paths to be passed on to
the IDL compiler. Specified either as absolute path or relative to the
location of the file in which the recipe is declared. Can be declared
multiple times.
Syntax::
rcp.idl_includes <<<Value type declarations,pathlist>>>

[source, ruby]
.example
----
base 'my_data' do \|dat\|
  dat.idl_includes %w{../data comp_data}
end
----

|[[base-gen_dir]]gen_dir
|
Description::
Specifies the output path for generated code (by the IDL
compiler). Default is 'generated_code'
Syntax::
rcp.gen_dir <<<Value type declarations,string>>>

[source, ruby]
.example
----
base 'my_data' do \|dat\|
  dat.gen_dir 'build'
end
----

|[[base-export_name]]export_name
|
Description::
Specifies the basename used for generated export macros.
By default the recipe_id is used as base name.
Syntax::
rcp.export_name <<<Value type declarations,string>>>

[source, ruby]
.example
----
base 'my_data' do \|dat\|
  dat.export_name 'my_base'
end
----

|[[base-shared_name]]shared_name
|
Description::
Specifies the basename used for creating shared libraries. By
default the recipe_id is used as base name.
Syntax::
rcp.shared_name <<<Value type declarations,string>>>

[source, ruby]
.example
----
base 'my_data' do \|dat\|
  dat.shared_name 'my_base_lib'
end
----

|=======================================================================

=== Value type declarations

To specify recipe property values the following value type declarations are supported.

[cols="<1,<3m",options="header",]
|=======================================================================
|Value type |Syntax

|<string>|
string := quote character_sequence quote +
quote := single_quote \| double_quote +
single_quote := “'” +
double_quote := '”'

*NOTE*: _quotes must match_

|<stringlist>|
stringlist := '%w{' character_sequence* '}' \| '[' strings ']' \| strings +
strings := string \| string ',' strings

*NOTE*: _'%w{ ... }' creates strings by splitting the enclosed character sequences on whitespaces_

|<symbol>|
symbol := colon character_sequence +
colon := ':'

|<symbollist>|
symbollist := '%i(' character_sequence ')' \| '[' symbols ']' \| symbols +
symbols := symbol \| symbol ',' symbols

*NOTE*: _'%i( ... )' creates symbols by splitting the enclosed character sequences on whitespaces_

|<pathlist>|
pathlist := '%w{' path_sequence* '}' \| '[' path_strings ']' \| path_strings +
path_strings := path_string \| path_string ',' path_strings
path_string := quote path_sequence quote +
path_sequence := path_character*

*NOTE*: _'%w{ ... }' creates strings by splitting the enclosed path_character sequences on whitespaces_ +
*NOTE*: _a path_sequence can contain an embedded environment variable reference as_ $(VAR)_, these references are automatically resolved_ +
*NOTE*: _a path_sequence can specify an absolute or a relative path where relative paths will always be resolved
        against the location of recipe file in which the path declaration is contained

|=======================================================================

// COMMENTED OUT
////

=== Examples

==== Component recipe


As you can see in the example below, this is the recipe of component with recipe name 'control', this name is used for naming of the (temporarily) mpc file name and as prefiex for the naming of the several
project files. +
The component interface is defined by the user in 'my_comp.idl', and APC also implemented the makefiles to generate, if not already delivered by the user, an my_comp_exec.cpp and my_comp_exec.h file with the
implementation of the component executor code.
This recipe specifies an additional include path and the output path for the
generated code. The component also has to use the base project 'taox11_anytypecode' and
needed  an extra source file 'test.cpp', besides the default 'control_comp_exec.cpp'.

-----------------------------------------
component 'control' do |comp|
  comp.idl %w{ my_comp.idl }
  comp.includes %w{ ../../comp_utils }
  comp.gen_dir  'build'
  comp.base_projects += 'taox11_anytypecode'
  comp.sources %w{test.cpp}
end
-----------------------------------------

==== Component interface definition

An example with the component interface defined by the recipe: +
The name of the idl file with the component interface becomes the recipe_id + '.idl', so in this case 'hello_sender.idl'
The used data interfaces by the component are mentioned with comp.idl

----------------------------------------------------------------------
component 'hello_sender' do |comp|
  #data/type idl
  comp.idl %w{ hello.idl foo.idl}

  #Define component 'Sender' in scope 'Hello'
  comp.define 'Hello::Sender' do |intf|

    # ---------         ports ----------------------------------
    #facet  port with interface Hello::MyFoo defined in hello.idl
    intf.port 'run_my_foo_uses' do |p|
      p.uses 'Hello::MyFoo'
    end

    #receptacle  port with interface Hello::MyFoo defined in hello.idl
    intf.port 'run_my_foo_prov' do |p|
      p.provides 'Hello::MyFoo'
    end

    # --------  attributes ----------------------------------------
    # readable attribute of base type
    intf.attribute 'my_sen_attrib' do |att|
      att.type 'short'
      # default is false
      att.readonly true
    end

    # readable attribute with type Foo::Bar, defined in foo.idl
    intf.attribute 'TestBar' do |att|
      att.type 'Foo::Bar'
      # readonly is false ( = default)
    end
    # ---------use  a timed trigger connectors ----------------------------------
    intf.timed_trigger_connector 'tt_scheduler'

  end

end
----------------------------------------------------------------------

Apc will generate the following hello_sender.idl file:

------------------------------------------------------
#ifndef HELLO_SENDER_IDL
#define HELLO_SENDER_IDL

#include <Components.idl>

#include <ccm_timed_trigger.idl>
#include "hello.idl"
#include "foo.idl"

module Hello
{
  /// A component
  component Sender
  {
    uses  Hello::MyFoo run_my_foo_uses;
    provides  Hello::MyFoo run_my_foo_prov;
    readonly attribute short my_sen_attrib;
    attribute Foo::Bar TestBar;
    uses CCM_TT::TT_Scheduler tt_scheduler;
   };
};
#endif /*  HELLO_SENDER_IDL  */

------------------------------------------------------

////

== What APC does for you and what *not*

The BRIX11 APC toolset helps you manage the your AXCIOMA projects making it easier to rearrange and
redesign your application as your development progresses. Still, there are things you have to do yourself.

Here is what APC takes care of for you:
[square]
* Generate a complete set of project build files, including full dependency information, based on the details
  it determines from meta information you put in to the recipes and what it can determine from any IDL files
  references in the project
* Through the generated project files and using RIDL integration fully automatically generate complete
  connector implementations
* Automatically generate component IDL definitions from component recipe interface declarations
* Through the generated project files drive IDL code (re-)generation and compilation

And here is what APC does *not* handle for you:
[square]
* Design and declare all IDL required for your application's messages (data structures and/or interfaces)
* Design and code your business functionality (driven from your component's executors)
* Design and implement your application's deployment plan

== Example projects

AXCIOMA is distributed with several tutorials and examples using APC as listed here.

.example and tutorial projects using APC
[square]
* `$CIAOX11_ROOT/examples/apc/` contains several basic APC example projects
* `$CIAOX11_ROOT/connectors/tt4ccm/examples/apc/` contains Timed Trigger APC example projects
* `$CIAOX11_ROOT/connectors/ami4ccm/examples/apc/` contains AMI4CCM APC example projects
* `$CIAOX11_ROOT/connectors/dds4ccm/examples/apc/shapes_asm` contains a specific DDS4CCM APC
  project example for which a specific <<../dds4ccm/dds4ccm_shapes_example#,tutorial>> is available

.regression tests using APC
[square]
* `$CIAOX11_ROOT/connectors/tt4ccm/tests/apc/`
* `$CIAOX11_ROOT/connectors/ami4ccm/tests/apc/`
* `$CIAOX11_ROOT/connectors/dds4ccm/tests/apc/`
* `$CIAOX11_ROOT/tests/apc/`
