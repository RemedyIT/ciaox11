#--------------------------------------------------------------------
# @file    config.rb
# @author  Marijke Hengstmengel
#
# @brief   IDL language mapping configuration for CCMX11 CORBA
#
# @copyright Copyright (c) Remedy IT Expertise BV
#--------------------------------------------------------------------

module IDL
  module CCMX11
    module CORBA
      COPYRIGHT = "Copyright (c) 2007-#{Time.now.year} Remedy IT Expertise BV, The Netherlands".freeze
      TITLE = 'RIDL CCMX11 CORBA Facet'.freeze

      ## Configure facet
      #
      Backend::Facet.configure('corba4ccm', File.dirname(__FILE__), TITLE, COPYRIGHT, IDL::CCMX11.ciaox11_version) do |fctcfg|
        def self.add_extended_options(ol)
          ol.for_switch '-G{generation options}', type: String, separator: true do |swcfg|
            swcfg.for_group :corba4ccm_group do |grpcfg|
              grpcfg.on_prepare do |arg, params|
                if /^corba4ccm\,(.*)/ =~ arg
                  return [::Regexp.last_match(1)]
                end

                nil
              end
              # IMPORTANT When these flags are updated also update the CORBA4CCM docs/src/ridlc.adoc
              # which is used for our user documentation
              grpcfg.for_params :strings,
              params: {
                'idl' => { option_name: :gen_idl_for_corba_connector,
                           description: "-Gcorba4ccm,idl\t\tGenerate the IDL file for the CORBA connector (not generated by default)" },
                'impl' => { option_name: :gen_exec_for_corba_connector,
                           description: "-Gcorba4ccm,impl\t\tGenerate the executor files for the CORBA connector (not generated by default)" },
                'conn' => { option_name: :gen_all_for_corba_connector,
                           description: "-Gcorba4ccm,conn\t\tGenerate all files needed for a CORBA connector (not generated by default)" },
              }
            end
          end

          ol.for_switch '-W<extended option>=OPT', type: String, separator: true do |swcfg|
            swcfg.modify_group :b_extopt do |grpcfg|
              grpcfg.modify_params :strings,
                                   params: {
                                       'conn_intf' => { description: "-Wb,conn_intf=SCOPED_INTERFACE\tspecifies scoped interface type name for connector generation" }
                                   }
            end
          end
        end # add_extended_options

        # setup backend option handling
        #
        fctcfg.on_setup do |optlist, ridl_params|
          ridl_params[:corba4ccm_pfx] = '_cc'
          CORBA.add_extended_options(optlist)
        end

        # process input / generate code
        # arguments:
        #   in parser - parser object with full AST from parsed source
        #   in options - initialized option hash
        #
        fctcfg.on_process_input do |parser, options|
          idl_ext = (options[:idlext] ||= File.extname(options[:idlfile]))

          if options[:gen_all_for_corba_connector]
            IDL::CCMX11::CORBA.gen_all_for_corba_connector(options)
          end

          if options[:gen_idl_for_corba_connector]
            IDL::CCMX11::CORBA.gen_idl_for_corba_connector(options)
          end

          if options[:gen_svnt_for_corba_connector]
            # input is the corba connector idl
            IDL::CCMX11::CORBA.gen_svnt_for_corba_connector(options, idl_ext)
          end

          if options[:gen_exec_for_corba_connector]
            # input is the corba connector idl
            IDL::CCMX11::CORBA.gen_exec_for_corba_connector(options, idl_ext)
          end
        end # fctcfg.on_process_input
      end # configure facet

      #
      # generate the IDL file for a CORBA connector
      #
      def self.gen_idl_for_corba_connector(options)
        options[:corba4ccm_idl_file] =
          File.join(options.outputdir,
            File.basename(options[:idlfile], options[:idlext]) + options[:corba4ccm_pfx] + options[:idlext])
        corba4ccm_idl_file = GenFile.new(options[:corba4ccm_idl_file])

        IDL.push_production(
            :corba_conn_idl,
            ::IDL::CCMX11::CORBA::IDLForCorbaConnectorWriter.new(corba4ccm_idl_file, options))
      end # gen_idl_for_corba_connector

      #
      # Generate CORBA connector servant code
      #
      def self.gen_svnt_for_corba_connector(options, idl_ext)
        # schedule servant implementation generation
        cc_opts = options.dup
        cc_opts[:suppress_regen] = true
        IDL::CCMX11.gen_component_servant(cc_opts, idl_ext)
        # extend generic servant generator for CORBA4CCM
        IDL.production(:comp_svnt_source).extend(IDL::CCMX11::Corba4ccmSvntConnectorSourceExt)
      end # gen_svnt_for_corba_connector

      #
      # Generate CORBA connector executor code
      #
      def self.gen_exec_for_corba_connector(options, idl_ext)
        # schedule executor implementation generation
        cc_opts = options.dup
        cc_opts[:suppress_regen] = true
        IDL::CCMX11.gen_component_executor(cc_opts, idl_ext)
        # extend generic executor generators for CORBA4CCM
        IDL.production(:comp_exec_header).extend(IDL::CCMX11::CorbaExecComponentHeaderExt)
        IDL.production(:comp_exec_source).extend(IDL::CCMX11::CorbaExecComponentSourceExt)
      end # gen_exec_for_corba_connector

      # This method drives 3 input processing passes:
      # 1. the current (main) pass processing the base IDL file passed on the command line
      #    - during this pass the following generator (production) is scheduled:
      #       I) xxx_cc.idl generation (declaring the CORBA4CCM templated connector instantiation)
      # 2. processing the xxx_cc.idl file generated in the first pass
      #    - during this pass the following generators (productions) are scheduled:
      #       I) xxx_ccC.h generation (CORBA4CCM connector stub header)
      #      II) xxx_cc_exec.* generation (CORBA4CCM connector executor implementation)
      #     III) xxx_cc_svnt.* generation (CORBA4CCM connector context&executor locator)
      #      IV) xxx_ccE.idl (CORBA4CCM connector LEM)
      # 3. processing the xxx_ccE.idl file generated in the second pass
      #    - during this pass the following generators (productions) are scheduled:
      #       I) xxx_ccEC.* generation (CORBA4CCM connector lem stubs)
      #      II) export header for xxx_ccEC code (if specified)
      #
      # generate ALL files for a CORBA connector
      def self.gen_all_for_corba_connector(options)
        options[:gen_idl_for_corba_connector] = false
        options[:gen_exec_for_corba_connector] = false

        # schedule generation of CORBA connector IDL
        self.gen_idl_for_corba_connector(options)

        # setup lem_stub export configuration for upcoming code and export header generation
        IDL::CCMX11.check_lem_stub_export_params(options, options[:corba4ccm_pfx])

        # restore new (clean) options set for new input processing pass
        cc_opts = options.restore
        # keep core option values (like include paths, macros and such)
        cc_opts.copy!(options, IDL::CORE_OPTIONS)

        # copy needed export settings
        cc_opts.copy!(options,
                      :base_export_include, :base_export_macro,
                      :stub_export_include, :stub_export_macro, :stub_export_file,
                      :lem_stub_export_include, :lem_stub_export_macro, :lem_stub_export_file,
                      :exec_export_include, :exec_export_macro, :exec_export_file,
                      :svnt_export_include, :svnt_export_macro, :svnt_export_file,
                      :gen_any_ops, :gen_typecodes, :gen_localintf_any_ops,
                      :gen_ostream_operators, :no_cdr_streaming)

        schedule_corba4ccm_idl_input(options, cc_opts)
      end # gen_all_for_corba_connector

      def self.schedule_corba4ccm_idl_input(options, cc_opts)
        # schedule lem IDL and code generation after connector IDL generation
        # generate only stub header
        cc_opts[:svnt_skeletons] = false
        cc_opts[:no_client_source] = true
        cc_opts[:no_client_proxy] = true
        # generate lem stub exports if -Gxhlst or -Gxhex or -Gxhsv are specified
        cc_opts.gen_export_lem_stub ||= options.gen_export_ex || options.gen_export_svnt
        # generate LEM IDL en (in yet another pass) the LEM stubs
        cc_opts[:gen_lem_gen] = true
        # generate CORBA4CCM connector servant and executor
        cc_opts[:gen_exec_for_corba_connector] = true
        cc_opts[:gen_svnt_for_corba_connector] = true
        cc_opts[:idlfile] = options[:corba4ccm_idl_file]
        IDL.push_input(options[:corba4ccm_idl_file], cc_opts)
      end

      # extend the base backend with some specific CORBA4CCM settings/handling
      module BaseExt
        def self.included(base)
          base.class_eval do
            # extend CCMX11#check_servant_export_params
            # use corba4ccm prefix for servant export names when generating corba4ccm connector
            def check_servant_export_params_with_corba(options, prefix = nil, force = false)
              if options.gen_all_for_corba_connector
                prefix ||= options[:corba4ccm_pfx]
              end
              check_servant_export_params_without_corba(options, prefix, force)
            end

            alias_method_chain :check_servant_export_params, :corba

            # extend CCMX11#check_executor_export_params
            # use corba4ccm prefix for connector executor export names when generating corba4ccm connector
            def check_executor_export_params_with_corba(options, prefix = nil, force = false)
              if options.gen_all_for_corba_connector
                prefix ||= options[:corba4ccm_pfx]
              end
              check_executor_export_params_without_corba(options, prefix, force)
            end

            alias_method_chain :check_executor_export_params, :corba
          end
        end
      end
    end # CORBA

    self.singleton_class.__send__(:include, CORBA::BaseExt)
  end # CCMX11
end # IDL
