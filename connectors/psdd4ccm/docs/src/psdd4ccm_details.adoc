include::_{backend}_settings.adoc[]

= Using PSDD4CCM connectors

== General

This document explains how to use PSDD4CCM connectors in combination
with LwCCM components at the hand of an example application provided in the *AXCIOMA* release.

Knowledge of LwCCM and pass:[IDL3+] is assumed.
For this example the link:{docs_root}/ciaox11/axcioma_project_tool.html[BRIX11 AXCIOMA Project Control] (APC) tools
are used, which are a set of link:{docs_root}/brix11/brix11.html[BRIX11] command extensions with the intent of
providing simplified and consistent project management for *AXCIOMA* based applications.

=== Application

The application consists of two components:

* Sender component
* Receiver component

In this example ZMQ middleware is used to transport the event information.
Since the sender and receiver are separate components, each
uses PSDD4CCM connectors which are deployed collocated with the user component.

The exchanged data events are defined as a struct (`Test::Message`) and as a simple string.
The `Message` struct has the following members:

[cols="<1,<1m,<3",options="header",]
|=========================================
|Member |Type |Functionality
|category |string |Provides the category of the message
|description |string |Provides a message description
|value |unsigned long |Provides the message value
|=========================================

.Type support
****
PSDD4CCM is a lot more flexible in it's support of IDL defined data types than DDS4CCM is.
In fact, except for valuetypes, any's and interfaces all IDL defined data types can be used
as PSDD4CCM events. +
The event data can either be organized in a struct or union, an array or sequence or
it can be a single data item like a (bounded) string, integer or floating point value.
****

For each event type, `Message` struct and string, a separate connector will be created and
deployed. Each component instance, Sender or Receiver, will be deployed with collocated
instances of each of these connectors.

=== Interaction Patterns

Two interaction patterns are used in this example application:

* Timed Trigger
* Event

The timed trigger pattern is implemented by the standard
<<{xref_docs_root}/tt4ccm/tt4ccm.adoc#,TT4CCM connector>> and the
event pattern by a
<<psdd4ccm.adoc#,PSDD4CCM connector>>. The
document will explain where and how these connectors will be used.

=== Directory structure

The following directory structure convention is used:

[source]
-------------------
/<root>         : Directory contains the project recipe
  /base         : Directory contains data IDL code for the project
  /components
    /sender     : Directory contains the recipe, IDL and *_exec-files for the component
    /receiver   : Directory contains the recipe, IDL and *_exec-files for the component
  /connector
    /zmq        : Directory contains the recipes for the connectors
-------------------

pass:[C++] source code files that are generated by the RIDL compiler are located in a
subdirectory, except the component executor starter code.
The default name of this subdirectory is `generated_code` unless 'gen_dir' is specified
in the recipes to change this default.

=== Typical work flow

The following work flow is suitable in most cases. All steps will be
described in more detail in this document:

.  Define your event data types in IDL
.  Optionally define your interfaces in IDL (when using request/reply patterns)
.  Define your components in IDL (unless you embed the component definition in the recipe)
.  Create recipe files
.  Generate your build files from the recipe files using the <<../ciaox11/axcioma_project_tool#_apc_prepare,BRIX11 APC prepare>> command
.  Do an initial compilation of your component, the RIDL compiler will
   generate your component executor starter code during this step. The easiest way is to use the
   <<../ciaox11/axcioma_project_tool#_apc_make,BRIX11 APC make>> command which will build your
   complete application
.  Implement your component business logic
.  Compile your components
.  Create your deployment plan
.  Deploy your application

== IDL

=== PSDD4CCM IDL

PSDD4CCM supports standard IDL defined data types for use as event types.
For support of event filtering and management of event type code generation PSDD4CCM
supports 2 IDL4-type annotations:

* `@nested` +
This annotation is used to specify the toplevel IDL type to be used as event type for
the implementation of PSDD4CCM connectors. This annotation is mandatory. Only IDL types
decorated with this annotation with value FALSE are supported as toplevel event types for PSDD4CCM.
* `@key` +
This annotation can be used to identify key member fields in `struct` definitions.

.RIDL annotation support
****
RIDL supports both the commented (`@//...`) and uncommented form of IDL4 annotations.
For compatibility reasons with other IDL(3) compilers it is recommended to use the
commented form.
****

==== Toplevel types

The standard IDL base types like the (unbounded) string types (`string` and `wstring`),
the character types (wide or not), the integer types (unsigned or signed), `boolean`
and the floating point types are all usable as toplevel event types. For these types
the `@nested(FALSE)` annotation is implicit.
Typedef definitions of these (or other) types however have to be explicitly specified as nested(FALSE)
in IDL.

.Standard typedefs
****
As standard typedefs like `CORBA::OctetSeq' are defined in standard IDL which cannot (and
should not) be upated with annotations these types cannot be directly used as toplevel types.
The way to use these as toplevel types would be to define another alias typedef for these
types in user defined IDL and decorate this typedef with the `@nested` annotation like
this:

[source,idl]
------------
@nested(FALSE)
typedef ::CORBA::OctetSeq MyOctetSeq;
------------
****

==== Keys

All non-constructed IDL types except for arrays and sequences as well as all `enum`-s are
considered key-only datatypes.
This means that the full data item of these types is considered it's key.
For simple types like the integer, character, boolean, and floating point types this does not
provide much options for filtering but for the string types PSDD4CCM supports filtering
on partial content (starting from the begin of the strings).
This would for instance allow filtering on certain prefixes.

IDL defined `union` types are unique in that they cannot be decorated with `@key` annotations
but are *not* considered key-only or key-less. Instead all `union` types are considered to have an
implicit key member which is the union's discriminator value.

IDL defined `struct` can be decorated with `@key` annotations for it's members.
Each member decorated is consider part of the key in the order in which the members are
declared in IDL.
The key member's values used for the key value are dependent on the IDL type of the member
(and in case of `struct` types their key definitions).

* In case of key-only datatypes the entire value of the member data item will be part of the
key value.
* In case the member type is a `union` type only the discriminator value of the member union
instance will be used for the key value.
* In case the member type is a `struct` type decorated with `@key` annotations only the
values of the key members will be used for the key value.
* In case the member type is a `struct` type *not* decorated with `@key` annotations all
values of all members will be used for the key value (in effect these struct members behave
as having key-only datatypes).

=== Data IDL

Below a simplified representation of the IDL that defines the
data type we use in this example. Use the link to view the file itself.
The following IDL can be found in `hello/base`:

.link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/base/message.idl[message.idl]
[source,idl]
-------------------
module Test
{
  @nested(FALSE)
  struct Message
  {
    string category; //@key
    string description;
    unsigned long value;
  };
};
-------------------

The `Message` struct is the the data structure that is published by the
sender.

This IDL file will be compiled by the
<<{xref_docs_root}/taox11/ridlc.adoc#,RIDL compiler>>. +
The key value for this struct is defined with `//@key` as shown above providing the
possibility for components to filter event subscriptions on `category` values.
The struct is decorated with `@nested(FALSE)` to specify that it is to be used as event type.

The example also uses a `string` as another event type. +
As this is a standard IDL base type no user data IDL definitions are required.

=== Connector IDL

Although it is possible to manually create the IDL defining the PSDD4CCM event interfaces
for the connectors this is not normally necessary.
<<{xref_docs_root}/taox11/ridlc.adoc#,RIDL>> provides all-in-one generation switches which
will create this IDL as intermediate generation steps based on data IDL (or even only on
type names in case of standard IDL base types).
This example uses this approach so there are no connector IDL files.

=== Component IDL

link:{docs_root}/ciaox11/axcioma_project_tool.html[BRIX11 APC] allows component IDL to be manually
defined in separate IDL files but also provides a higher level syntax to define component
interfaces embedded in the component recipes. This example uses both approaches.
The recipe for the Sender component uses the manually defined IDL file
link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/sender/psdd_sender.idl[psdd_sender.idl]
and the recipe for the Reciever component uses an embedded component interface definition
(see <<#_receiver_recipe,below>>).
We'll discuss the component interfaces in more detail with the recipe descriptions below.

== Recipes

An APC based project contains one <<../ciaox11/axcioma_project_tool#_project_recipe,project recipe file>> and one or more
<<../ciaox11/axcioma_project_tool#_application_recipes,application recipe files>> where the recipes for the application
artifacts are defined.

=== Project recipe file

An APC based project is assumed to be stored in a directory tree with a single common root.This root is
marked by the existence of a project recipe file stored at that location using a fixed name (`aprc`).
The project recipe contains the directories where the data and interface IDL files are located. +
In this example it contains `prj.idl_includes %w{ base }`, because
it is the base directory in this example where the common data IDL file is located.

.project recipe in link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/aprc[hello/aprc]
[source,ruby]
--------------------------
prj.idl_includes %w{ base }
--------------------------

=== Application recipes

APC defines various recipe types for different application products like
connectors, components and optionally data. Product recipes are stored
in text files using APC DSL (Domain Specific Language) definitions. A
recipe file can have any name ending with a fixed extension ('.aprc').
See also <<../ciaox11/axcioma_project_tool#_application_recipes,here>> for more details.

For this example we use recipe files for the
link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/connector/zmq/conn.aprc[ZeroMQ connectors], the
link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/receiver/receiver.aprc[receiver
component] and the
link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/sender/sender.aprc[receiver
component].

==== Base recipes

For the data IDL files, such as the `message.idl`, no recipe is
necessary. APC creates implicit recipes when it determines
an IDL file is needed by other IDL files referenced in a project.
See <<../ciaox11/axcioma_project_tool#_base_recipe,here>> for more information on these recipes.

==== Connector recipes

The PSDD4CCM ZMQ connector recipe for the string event interface looks like:

[source, ruby]
---------------------------------------
connector 'hello_psdd_zmq_conn' do |conn|

  # conn.idl %w{ ... }

  # prefix of generated export headers (default: recipe_id)
  conn.export_name 'hello'

  # For the shared name of the psdd4ccm connector,
  # the project creator adds '_psdd_<middleware>_conn' after
  # the property 'shared_name' (default: recipe id)
  conn.shared_name 'hello'

  conn.port_type :psdd4ccm do |tp|
    tp.topic 'string'
    tp.topic_namespace 'Test'
    tp.topic_sequence 'StringSeq_t'
    tp.topic_interface 'Hello'
    tp.middleware :zmq
  end

  # gen_dir is default 'generated_code'

end
---------------------------------------

And the PSDD4CCM ZMQ connector recipe for the `Message` event interface looks like:

[source, ruby]
-----------------------------------------
connector 'msg_psdd_zmq_conn' do |conn|

  conn.idl %w{ message.idl }

  # prefix of generated export headers (default: recipe_id)
  conn.export_name 'msg'

  # For the shared name of the psdd4ccm connector
  # the project creator adds '_psdd_<middleware>_conn' after
  # the property 'shared_name' (default: recipe id)
  conn.shared_name 'msg'

  conn.port_type :psdd4ccm do |tp|
    tp.topic 'Test::Message'
    tp.topic_sequence_suffix 'Seq_t'
    tp.topic_interface 'Msg'
    tp.middleware 'zmq'
  end

  # gen_dir is default 'generated_code'

end
-----------------------------------------

The `topic` property specifies the data (event) type the connector should support
for read and write operations in it's interface.

Based on this information the APC tool will automatically generate an IDL file
declaring the event interface types for the connector to use. The name for
this file is based on the IDL file specified in the connector recipe or the topic
type name in case of standard IDL types, which in this case results in
`stringPS.idl` and `messagePS.idl`.

.stringPS.idl
[source, idl]
-----------------------------------------------------------------------
#include <ccm_psdd.idl>

module Test
{
  typedef sequence<string> StringSeq_t;

  module ::CCM_PSDD::Typed<string, StringSeq_t> Hello;
}; /* Test */
-----------------------------------------------------------------------

.messagePS.idl
[source, idl]
-----------------------------------------------------------------------
#include <ccm_psdd.idl>

#include "message.idl"

module Test
{
  typedef sequence<Test::Message> MessageSeq_t;

  module ::CCM_PSDD::Typed<Test::Message, MessageSeq_t> Msg;
}; /* Test */
-----------------------------------------------------------------------

For connectors several other properties can be set in the recipe. See
<<../ciaox11/axcioma_project_tool#_connector_recipe,here>> for an overview of possible properties.

==== Component recipes

For a component several properties can be set in the recipe. In case an optional property is
not set, the default is applied. See <<../ciaox11/axcioma_project_tool.html#_component_recipe,here>> for an overview of possible properties.

===== Sender recipe

The recipe for the Sender component looks like this:

.sender.aprc
[source,ruby]
--------------------------------------------------------------------------
component 'psdd_sender' do |comp|

  comp.idl %w{ psdd_sender.idl }

  comp.base_projects += 'ciaox11_psdd4ccm_logger'

  # prefix sharednames, default recipe name (in this case: shapes_sender_comp)
  # prefix export headers, default recipe name in uppercase
  # gen_dir is default 'generated_code'

end
--------------------------------------------------------------------------

and the IDL for the Sender component looks like this:

.psdd_sender.idl link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/sender/psdd_sender.idl[here]
[source, idl]
-----------------------------------------------------------------------
#include "stringPS.idl"
#include "messagePS.idl"
#include <ccm_timed_trigger.idl>

module Test
{
    component Sender
    {
        uses Test::Hello::Publisher  hello_pub;
        uses Test::Msg::Publisher msg_pub;

        uses CCM_TT::TT_Scheduler tt_scheduler;

        attribute string mode;
        attribute unsigned long count;
        attribute unsigned long delay; // msec
    };
};
-----------------------------------------------------------------------

The `mode` attribute can be used to control at deployment time whether the Sender
component will publish `Test::Hello` events, `Test::Message` events or both.
The `count` attribute can be used to control at deployment time how many event samples
the Sender component publishes.
The `delay` attribute can be used to control at deployment time how long the Sender
component delays before starting to publish (a crude sender/receiver syncing mechanism).

The Sender component uses a link:{docs_root}/tt4ccm/tt4ccm.html[Timed Trigger] port to
schedule periodic triggers for sending event samples using one or both of the
PSDD4CCM ports defined.

===== Receiver recipe

The recipe for the Receiver component looks like this:

.receiver.aprc
[source,ruby]
--------------------------------------------------------------------------
component 'psdd_receiver' do |comp|

  comp.idl %w{ message.idl }

  comp.define 'Test::Receiver' do |intf|
    intf.port 'hello_sub' do |port|
      port.subscribes 'string', listen: 'hello_listen', get: 'hello_read'
    end
    intf.port 'msg_sub' do |port|
      port.subscribes 'Test::Message', :listen => 'msg_listen', :get => 'msg_read'
    end
    intf.port 'tt_scheduler', :timed_trigger

    intf.attribute 'mode', type: 'string'
    intf.attribute 'subscription', type: 'string'
    intf.attribute 'count', type: 'unsigned long'
    intf.attribute 'delay', type: 'unsigned long'
    intf.attribute 'interval', type: 'unsigned long'
  end

  comp.base_projects += 'ciaox11_psdd4ccm_logger'

  # prefix sharednames, default recipe id (in this case: shapes_receiver_comp)
  # prefix export headers, default recipe id in uppercase
  # gen_dir is default 'generated_code'

end
--------------------------------------------------------------------------

This component recipe embeds a component interface definiton that will result in
component IDL like this:

.generated Receiver IDL
[source, idl]
-----------------------------------------------------------------------
#include <Components.idl>
#include <ccm_timed_trigger.idl>

#include "stringPS.idl"
#include "messagePS.idl"

module Test
{
  component Receiver
  {
    uses Test::Hello::Subscriber hello_sub;
    uses Test::Msg::Subscriber msg_sub;
    uses CCM_TT::TT_Scheduler tt_scheduler;
    provides Test::Hello::Listener hello_listen;
    uses Test::Hello::Getter hello_read;
    provides Test::Msg::Listener msg_listen;
    uses Test::Msg::Getter msg_read;
    attribute string mode;
    attribute string subscription;
    attribute unsigned long count;
    attribute unsigned long delay;
    attribute unsigned long interval;
  };
};
-----------------------------------------------------------------------

The `mode` attribute can be used to control at deployment time whether the Receiver
component will subscribe to `Test::Hello` events, `Test::Message` events or both as
well as to control whether the Receiver will use reader (getter) ports, listener ports
or both.
The `subscription` attribute can be used to control at deployment time to filter the
subscription to events.
The `count` attribute can be used to specify at deployment time how many event samples
are expected to be read/received.
The `delay` attribute can be used to control at deployment time how long the Receiver
component delays before starting to read/get event samples (a crude sender/receiver
syncing mechanism).
The `interval` attribute can be used to control at deployment time how frequently the
Receiver component reads/gets event samples.
Listening does not need/use delays and intervals.

The Receiver component uses a link:{docs_root}/tt4ccm/tt4ccm.html[Timed Trigger] port to
schedule periodic triggers for reading/getting event samples using the one or both of the
PSDD4CCM reader/getter ports defined.

== Building

=== AXCIOMA Project Control tools

In this example we use the BRIX11 AXCIOMA Project Control tools (APC) to generate the make files (Linux) or
the solution/VC-project files (Windows) and build the application. +

APC makes sure that the commandline parameters for both the RIDL compiler and the {cpp}
compiler are used correct and consistent throughout the AXCIOMA/PSDD4CCM core as well
as the user's business logic.
This part of this document describes how to use APC for this example.

=== Component executor starter code

Once the IDL is written the user should implement the component executor
business logic. To make it easier for the user, the RIDL compiler is
able to generate the initial component executor starter code. This
results in a {cxx11} source code file where:

* The facet executor classes are provided
* The components attributes are declared as private class members
* The getter and setter methods for attributes are declared and implemented
* The facet factory methods are implemented
* The life cycle methods are also available.

The RIDL compiler also makes sure that when the IDL is changed, the
component executor is updated without loosing your existing business code.
Therefor it uses so called re-generation markers throughout the
component executor code. Re-generation markers look like this:

[source,c++]
-------------------------------------------------------------------------------------------------
void
Receiver_exec_i::mode (
    const std::string& mode)
{
  //@@{__RIDL_REGEN_MARKER__} - BEGIN : Test_Receiver_Impl::Receiver_exec_i::mode[setter]
  this->mode_ = mode;
  //@@{__RIDL_REGEN_MARKER__} - END : Test_Receiver_Impl::Receiver_exec_i::mode[setter]
}
-------------------------------------------------------------------------------------------------

All code between these markers will be preserved when the executor code
is re-generated, except (off course) when the mode-attribute will be
removed from IDL. An example of an (implemented) component executor code
file can be found
link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/receiver/psdd_receiver_exec.cpp[here]

Re-generation is enabled by default with the regular AXCIOMA distributions. Removing the entry `ciaox11_noregen_exec=0`
from the `default.features` file (located in `$ACE_ROOT/bin/MakeProjectCreator/config`) would disable regeneration.

=== Generating makefiles

To run APC, in order to generate all makefiles for a project execute the following command from any project directory
(under `$CIAOX11_ROOT/connectors/psdd4ccm/examples/hello`):

`/path/to/brix11 apc prepare` +
or +
`/path/to/brix11 apc prepare -m`

With the `-m` option the transient MPC files are not removed
after the makefiles are generated. Default, without this option, the
MPC files are removed after the makefiles are generated.

NOTE: An additional command to remove all generated directories and files from the `apc prepare` command is: +
`/path/to/brix11 apc clean`

=== Compiling

Execute the following command from any project directory:

`/path/to/brix11 apc make`

This will compile the IDL and the (generated) C++11 code. Notice that
all code will be generated in the subdirectory `generated_code` or in the subdirectory
indicated in the recipes with the `gen_dir` property, except the component executor code files
(*_exec.cpp and *_exec.h) as these are not considered transient files and are kept at the same
location as other non-transient files like the recipe files. All libraries are collected in
the `lib` subdirectory.

If the compilation succeeds successfully the application is ready to be deployed when a deployment plan
has been set up.
In case of a newly created project this would also work but would achieve little as the (newly) generated
component executors would not have any business code added yet. In this example the business code for the
executors has already been added and the executor files have merely been regenerated leaving the business
code intact. The example application is therefor ready for deployment.

=== Implementing business code

All what would be left before the actual deployment of a new application would be the
implementation of the business code.
For this example that implementation has been included. Please have a look at the following
implementation files to check out that implementation:

Sender::

** link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/sender/psdd_sender_exec.cpp[Source]
** link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/sender/psdd_sender_exec.h[Header]

Receiver::

** link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/receiver/psdd_receiver_exec.cpp[Source]
** link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/receiver/psdd_receiver_exec.h[Header]

Compilation of this example will generate the following "functional"
libraries. These libraries will be mentioned in the deployment plan
(next step in this document).

[cols="<m,<3",options="header",]
|=======================================================================
|Library |Purpose

|psdd_receiver_exec.so |Contains the executor implementation of the
Receiver component

|psdd_receiver_svnt.so |Contains the framework integration parts of the
Receiver component

|psdd_sender_exec.so |Contains the executor implementation of the Sender
component

|psdd_sender_svnt.so |Contains the framework integration parts of the Sender
component

|msg_psdd_zmq_conn.so |Contains the implementation of the ZeroMQ PSDD4CCM
connector for "Test::Message"

|hello_psdd_zmq_conn.so |Contains the implementation of the ZeroMQ PSDD4CCM
connector for "string"
|=======================================================================

== Deployment

In order to deploy an application a deployment plan and
deployment tools are neeed. *AXCIOMA* provides a set of deployment tools for which
the documentation can be found
<<{xref_docs_root}/dancex11/dancex11.adoc#,here>>. +
The *AXCIOMA* deployment tools support two types of deployment plans:
an XML-based plan and a CONFIG based plan. These plans are typically
generated by the modeling tools. Only the latter will be discussed here.
For more information about this format, please have a look at the
deployment tool documentation regarding
<<{xref_docs_root}/dancex11/config-plan.adoc#,plans>>.

=== Deployment plan

This simple example deploys the application distributed over two nodes; the SenderNode for
the Sender related components and the ReceiverNode for the Receiver related components.

The part of a
link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/descriptors/plan_zmq_read.config[config plan] that
deals with deploying the Sender node for reader/getter testing with ZeroMQ connectors
is shown below. +
The first section of this
part of the plan declares the locality (SenderLocality), indicating its
name and on which node it runs (SenderNode). +
The second section declares the Sender component itself, listing the node
on which it should run (SenderNode) and in which locality it should be
deployed (SenderLocality). +
The third section declares the TT4CCM connector for the Sender component.
The connection of the Sender component to this connector is declared as part
of the Sender component section above. +
The fourth section declares the `string` PSDD4CCM connector for the Sender
component. Besides the node and the locality property, it also specifies a number of
ConfigProperties. These properties and their use are described in more detail
<<psdd4ccm_deployment.html#,here>>. It also declares the connection between this
connector and the Sender component. +
The fifth and last section declares the `Message` PSDD4CCM connector for the Sender
component. Besides the node and the locality property, this connector as well specifies
a number of ConfigProperties. It also declares the connection between this
connector and the Sender component.

[source,CONFIG]
----
#=====================================================
# Definitions for Sender Node/Locality
#-----------------------------------------------------
# locality manager instance for locality "SenderLocality" on Node "SenderNode"
nl.remedy.it.DnCX11.LocalityManager SenderComponentServerInstance
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"

# SenderComponent instance
nl.remedy.it.CCM.Component SenderComponent psdd_sender_exec create_Test_Sender_Impl
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Artifact "psdd_sender_svnt"
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Test_Sender_Servant"
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"
    nl.remedy.it.DnCX11.ConfigProperty count uint32:100
    nl.remedy.it.DnCX11.ConfigProperty mode "MSG"
    nl.remedy.it.DnCX11.Connection SenderTimedTriggerProvider
      tt_scheduler < tt_scheduler

# SenderTimedTriggerProvider instance
nl.remedy.it.CCM.Component SenderTimedTriggerProvider ciaox11_tt4ccm_conn create_CIAOX11_TT_TimedTrigger_Impl
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_CIAOX11_TT_TimedTrigger_Servant"
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"

# Sender_HelloConnector instance
nl.remedy.it.CCM.Component Sender_HelloConnector hello_psdd_zmq_conn create_Test_Hello_PSDD_Event_Impl
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"
    nl.remedy.it.DnCX11.ConfigProperty topic_name "AXCIOMA::Hello"
    nl.remedy.it.DnCX11.ConfigProperty publish true
    nl.remedy.it.DnCX11.ConfigProperty nl.remedy.it.PSDD.ZMQ.Publisher.Endpoints ["tcp://*:50005"]
    nl.remedy.it.DnCX11.Connection SenderComponent
      supplier_data > hello_pub

# Sender_MsgConnector instance
nl.remedy.it.CCM.Component Sender_MsgConnector msg_psdd_zmq_conn create_Test_Msg_PSDD_Event_Impl
    nl.remedy.it.DnCX11.Node "SenderNode"
    nl.remedy.it.DnCX11.Locality "SenderLocality"
    nl.remedy.it.DnCX11.ConfigProperty topic_name "AXCIOMA::Message"
    nl.remedy.it.DnCX11.ConfigProperty publish true
    nl.remedy.it.DnCX11.ConfigProperty nl.remedy.it.PSDD.ZMQ.Publisher.Endpoints ["tcp://*:50005"]
    nl.remedy.it.DnCX11.Connection SenderComponent
      supplier_data > msg_pub
----

Some highlights of this part of the plan:

----
nl.remedy.it.CCM.Component SenderComponent psdd_sender_exec create_Test_Sender_Impl
----
This line declares a component instance with unique id `SenderComponent` and executor library `psdd_sender_exec`
having an executor factory entrypoint `create_Test_Sender_Impl`.

----
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Artifact "psdd_sender_svnt"
    nl.remedy.it.DnCX11.ExecParameter nl.remedy.it.DnCX11.Servant.Factory "create_Test_Sender_Servant"
----

Declaration of which library contains the servant code and which entrypoint to use for the servant.

----
    nl.remedy.it.DnCX11.ConfigProperty count uint32:100
    nl.remedy.it.DnCX11.ConfigProperty mode "MSG"
----

Initial values for the attributes (`count` and `mode`).

----
nl.remedy.it.CCM.Component Sender_HelloConnector hello_psdd_zmq_conn create_Test_Hello_PSDD_Event_Impl
    ...
    nl.remedy.it.DnCX11.Connection SenderComponent
      supplier_data > hello_pub
----

Declares the connection from the PSDD4CCM connector to the Sender component. We connect the `Publisher`
interface of the "supplier_data" port (provider) on the PSDD4CCM connector to the `Publisher` interface
of the "hello_pub" port (user) on the Sender component.
(see <<psdd4ccm_design.html#,PSDD4CCM design>> and
link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/components/sender/psdd_sender.idl[Sender component IDL]
for more information). +
Combining this all gives: `supplier_data > hello_pub`. +
A connection statement always begins with the (extended) port name of the current
connector/component and ends with the (extended) port name of the other connector/component.
The connector symbol (`<` or `>`) points from the facet (provider) to the receptacle (user).

The part of the plan that deals with the ReceiverNode contains similar deployment descriptors
that deploy the Receiver component with it's associated connectors and connects the required
ports (in this case the ports for the `Getter` and `Subscriber` interfaces).

The link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/descriptors[deployment folder]
for this example contains multiple deployment plans to configure/test the various options like using ZMQ
connectors, using the `Listener` interface ports instead of the `Getter` ports or both, filtering
subscriptions and using secured connections.

== Running

=== Run time

Information about the execution model of the *AXCIOMA* deployment tools
can be found
<<{xref_docs_root}/dancex11/deployment-execution.adoc#,here>>.

In *AXCIOMA* every example/test is accompanied by a Perl script. This
Perl script contains the execution steps which are necessary to deploy
the example or test. Have a look at the Perl script of this example
which can be found
link:{docs_root}/../../ciaox11/connectors/psdd4ccm/examples/hello/deployment/descriptors/run_test.pl[here].

=== Logging

The following environment variables will turn all PSDD4CCM logging on:

---------------------------------------------------------------------
PSDD4CCMX11_LOG_MASK='all'
PSDD4CCMX11_LOG_VERBOSITY='prio|thread|process|time|datetime|category'
---------------------------------------------------------------------

More information about which values can be used for the above mentioned
environment variables can be found <<{xref_docs_root}/taox11/x11_logging.adoc#,here>>.
