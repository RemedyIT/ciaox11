include::_{backend}_settings.adoc[opts=optional]

= Component Executor starter code

== Code generation

Consider the following link:{code_root}/ciaox11/executor_starter/base/starter.idl[data IDL]:

[source,idl]
.starter.idl
-----------------------------------------------------
module Hello
{
  exception Ball
  {
    string error;
  };

  interface MyFoo
  {
    string foo (in string in_str, out string answer)
      raises (Ball);

    attribute short foo_attrib;

    attribute short foo_excep
      getraises (Ball)
      setraises (Ball);
  };

  interface MyBar
  {
    string bar (in string in_str, out string answer);

    attribute short bar_attrib;

    readonly attribute short ro_bar_attrib;
  };

  porttype foo_bar
  {
    provides MyFoo foo;
    uses MyBar bar;
  };

};
-----------------------------------------------------

And the following
link:{code_root}/ciaox11/executor_starter/component/starter_component.idl[component definition]:

[source,idl]
.starter_component.idl
-----------------------------------------------
module Hello
{
  component Receiver
  {
    provides MyFoo do_my_foo;
    mirrorport foo_bar do_foo_bar;

    attribute unsigned short just_an_attribute;
  };
};
-----------------------------------------------

Running the following command makes sure that the
xref:{xref_docs_root}/taox11/ridlc.adoc#[RIDL compiler] only generates the
component executor starter code:

--------------------------------------------------------------------------------------------------
ridlc -I$CIAOX11_ROOT -I$CIAOX11_ROOT/ccm -I ../base -SS -Ssh -Scc -Sch -Scph -Gex -oI . starter_component.idl
--------------------------------------------------------------------------------------------------

Where:

[cols="<1s,<4",options="header",]
|=======================================================================
|Commandline option |Description
|-I |Directives are the include paths
|-SS |Suppresses the generation of the skeleton source
|-Ssh |Suppresses the generation of the skeleton header
|-Scc |Suppresses the generation of the stub source
|-Sch |Suppresses the generation of the stub header
|-Scph |Suppresses the generation of the stub proxy header
|-Gex |Triggers the generation of the component executor starter code
|-oI |Indicates where the component executor starter code should be generated
|=======================================================================

The above command will generate two files with `_exec` as postfix.

The component executor header can be found
link:{code_root}/ciaox11/executor_starter/component/starter_component_exec.h[here]. The
component executor source can be found
link:{code_root}/ciaox11/executor_starter/component/starter_component_exec.cpp[here].

In general, the starter code includes:

* The class definition of the component, concatenating the name of the
component IDL and `_exec_i` (`Receiver_exec_i` in this case).
* The getter and setter methods as well as the private class members of
all attributes configured on the component.
* Interaction support for
xref:{xref_docs_root}/dancex11/dancex11.adoc#[*AXCIOMA*] deployment tooling>>:
** Life cycle methods:
*** `configuration_complete`
*** `ccm_activate`
*** `ccm_passivate`
*** `ccm_remove`
** A setter method for the context (`set_session_context`) as
well as a private class member (`context_`), holding the reference to
the context of the component. More information about the context of a
business component can be found on <<component_context.adoc#,this
page>>.
** Getter methods for all generated facet classes (as well as the
private class members, holding the reference to the facets). In the
above example, the following getter methods will be generated:
*** `get_do_my_foo`
*** `get_do_my_bar`
+
and the following private class members of the component executor class
will be generated:
*** `do_my_foo_`
*** `do_my_bar_`
* A class definition for each provided interface (facet). The name of
this class will be constructed in two ways, depending on the declaration
of the component port:

In case of a base port declaration::

In this case the class name will be the concatenation of the facet name
and `_exec_i`. In this example MyFoo is declared as base port and
therefor the class name will be `do_my_foo_exec_i`.

In case of an extended port declaration::

The example component declares an extended port (`do_foo_bar`) as
mirrorport. Therefor the business component provides a `MyBar` interface.
The class name of this facet will be a concatenation of
``<extended_port_name>``_``<base_port_name>`` and
`_exec_i`. In this case the class name of this facet will be
`do_foo_bar_bar_exec_i`.

Again, the getter and setter methods as well as the private class
members of all attributes configured on the facet are generated as well.

== Re-generation markers

Besides all this, re-generation markers are generated by the RIDL
compiler. This means that when the IDL of a business component changes,
non of the implemented business code will be lost (unless the code is not
bracketed by re-generation markers)!

A re-generation marker pair looks like this:

[source,c++]
--------------------------------------------------------------------------------------------
//@@{__RIDL_REGEN_MARKER__} - BEGIN : Hello_Receiver_Impl::do_my_bar_exec_i[user_public_ops]
// Your code here
//@@{__RIDL_REGEN_MARKER__} - END : Hello_Receiver_Impl::do_my_bar_exec_i[user_public_ops]
--------------------------------------------------------------------------------------------

At least the following re-generation markers are generated for:

* The file header (header/source)
* User defined includes (header/source)
* Global user declarations (header/source)
* Namespace user declarations (at the beginning and at the end of a
namespace) (header/source)
* Facet Constructors (header/source)
* The life cycle methods (source only)
* Getters and setters for attributes (source only)
* User defined public operations in the component executor class
(header/source)
* User defined private operations in the component executor class
(header/source)
* User defined members in the component executor class (header)
* User defined public operations in the facet executor class
(header/source)
* User defined private operations in the facet executor class
(header/source)
* User defined members in the facet executor class (header)
* The file footer (header/source)

Please have a look at the above mentioned generated code for more
details.

== MPC

There is a MPC base project `$CIAOX11_ROOT/MPC/config/ciaox11_gen_exec`.
This base project makes sure that the component executor starter code will always be
(re)generated when the MPC feature `ciaox11_noregen_exec` is set to `0`
in `default.features` (for more info regarding MPC features, see
link:{docs_root}/../../ACE/MPC/docs/USAGE[MPC].
