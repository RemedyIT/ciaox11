/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_PSDD_SENDER_SVNT_H_IDFCAFCH_INCLUDED__
#define __RIDL_PSDD_SENDER_SVNT_H_IDFCAFCH_INCLUDED__

#pragma once

#include /**/ "psdd_sender_svnt_export.h"

#include "psdd_senderEC.h"

#include "ccm/ccm_serviceregistryC.h"
#include "ccm/ccm_executorlocatorC.h"

#include /**/ "ciaox11/versionx11.h"

#if CIAOX11_MAJOR_VERSION != 2 || CIAOX11_MINOR_VERSION != 3 || CIAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL CCMX11 backend version (2.3.0). Please re-generate.
#endif

// generated from ccmx11/templates/svnt/hdr/component
namespace Test_Sender_Impl
{

  /**
   * Context implementation class for the ::Test::CCM_Sender
   * component.
   */
  class Sender_Context final
    : public IDL::traits< ::Test::CCM_Sender_Context>::base_type
  {
  public:
    /**
     * Constructor for the context.
     * @param svcreg The ServiceRegistry for this component
     * @param ins_name The name of the component instance as mentioned in the deployment plan.
     */
    Sender_Context (IDL::traits<CIAOX11::Service_Registry>::ref_type svcreg, std::string ins_name);

    /// Destructor
    ~Sender_Context () override = default;

    /// Retrieve the service registry
    IDL::traits<CIAOX11::Service_Registry>::ref_type the_service_registry () override;

    /// @name Accessors for all receptacles
    //@{
    /// Get the hello_pub receptacle
    IDL::traits< ::Test::Hello::Publisher>::ref_type get_connection_hello_pub () override;
    /// Get the msg_pub receptacle
    IDL::traits< ::Test::Msg::Publisher>::ref_type get_connection_msg_pub () override;
    /// Get the tt_scheduler receptacle
    IDL::traits< ::CCM_TT::TT_Scheduler>::ref_type get_connection_tt_scheduler () override;
    //@}

    friend class Sender_ExecutorLocator;

    /// readonly attribute which holds the instance name of the
    /// component. This instance name is supplied to the servant factory
    /// method by the deployment tools and represents the name of the
    /// component in the deployment plan.
    std::string instance_id () override;

  private:
    // generated from ccmx11/templates/svnt/hdr/context_set_connection
    /// Connect method to set the connection for receptacle with name @a name.
    bool set_connection (const std::string& name,
                         IDL::traits<CORBA::Object>::ref_type port);

    // generated from ccmx11/templates/svnt/hdr/context_reset_connection
    /// Disconnect method to reset the connection for receptacle with name @a name
    bool reset_connection (const std::string& name);

    /// The ServiceRegistry for this component
    IDL::traits<CIAOX11::Service_Registry>::ref_type service_registry_ {};
    /// The instance name of the component
    std::string const instance_id_ {};

    /// @name Member variables for storing all receptacles
    //@{
    /// Member variable for storing a reference for the hello_pub receptacle
    IDL::traits< ::Test::Hello::Publisher>::ref_type hello_pub_{};
    /// Member variable for storing a reference for the msg_pub receptacle
    IDL::traits< ::Test::Msg::Publisher>::ref_type msg_pub_{};
    /// Member variable for storing a reference for the tt_scheduler receptacle
    IDL::traits< ::CCM_TT::TT_Scheduler>::ref_type tt_scheduler_{};
    //@}

    //@{
    /** Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    Sender_Context () = delete;
    Sender_Context (const Sender_Context&) = delete;
    Sender_Context (Sender_Context&&) = delete;
    Sender_Context& operator= (const Sender_Context&) = delete;
    Sender_Context& operator= (Sender_Context&&) = delete;
    //@}
  };

  /**
   * ExecutorLocator for the Sender component. This
   * gives access to all middleware generated pieces that are used
   * by the CCM infrastructure
   */
  class Sender_ExecutorLocator final
    : public IDL::traits<CIAOX11::ExecutorLocator>::base_type
  {
  public:
    /**
    * Constructor
    * @param component_executor The user implemented executor
    * @param component_context The context that is passed to the executor
    */
    Sender_ExecutorLocator (
      IDL::traits<::Test::CCM_Sender>::ref_type component_executor,
      IDL::traits<Sender_Context>::ref_type component_context);

    /// Destructor
    ~Sender_ExecutorLocator () override = default;

    /**
     * Configure the component
     */
    void configure (::Components::ConfigValues& config) override;

    /**
     * Connect a component port.
     * @retval true Connecting the port has succeeded
     * @retval false Connecting the port has failed
     */
    bool connect (const ::Components::FeatureName& name,
                  IDL::traits<CORBA::Object>::ref_type connection,
                  const std::string& conn_name,
                  const ::Components::ConfigValues& config) override;

    /**
     * Disconnect a component port.
     * @retval true Disconnecting the port has succeeded
     * @retval false Disconnecting the port has failed
     */
    bool disconnect (const ::Components::FeatureName& name,
                     const std::string& conn_name) override;

    /**
     * Obtain the component executor.
     */
    IDL::traits<CORBA::Object>::ref_type obtain_executor () override;

    /**
     * Obtain a facet executor for the given @a name using the the given @a config.
     * If there is no facet executor returned by the component executor we just
     * return nullptr. If we have to get an executor for an invalid facet
     * name we throw an InvalidName() exception
     */
    IDL::traits<CORBA::Object>::ref_type obtain_facet_executor (
                          const ::Components::FeatureName& name,
                          ::Components::ConfigValues& config) override;

  private:
    /**
    * At the moment a component has attributes, we loop
    * through the passed set and based on the name of the
    * attribute call a setter of the executor we have as member.
    * Throws a CIAOX11::ConfigurationError at the moment one or more
    * of the matching config values can't be set on the executor
    * (extraction errors or readonly attributes).
    */
    void set_configuration (const Components::ConfigValues& descr);

    /// Reference to the user implemented executor
    IDL::traits<::Test::CCM_Sender>::ref_type component_executor_;

    /// The context for this component
    IDL::traits<Sender_Context>::ref_type component_context_;

    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    Sender_ExecutorLocator () = delete;
    Sender_ExecutorLocator (const Sender_ExecutorLocator&) = delete;
    Sender_ExecutorLocator (Sender_ExecutorLocator&&) = delete;
    Sender_ExecutorLocator& operator= (const Sender_ExecutorLocator&) = delete;
    Sender_ExecutorLocator& operator= (Sender_ExecutorLocator&&) = delete;
    //@}
  };
} // namespace Test_Sender_Impl

/**
 * Factory method to create an executor locator for a
 * Test_Sender_Impl component
 * @param component_executor The user component executor for which we need
 * to create the executor locator
 * @param svcreg The ServiceRegistry for this component
 * @param ins_name The unique name of this component
 * @param executor_locator The created executor locator
 */
extern "C" PSDD_SENDER_SVNT_Export  void
create_Test_Sender_Servant (
  IDL::traits<Components::EnterpriseComponent>::ref_type component_executor,
  IDL::traits<CIAOX11::Service_Registry>::ref_type svcreg,
  const std::string& ins_name,
  IDL::traits<CIAOX11::ExecutorLocator>::ref_type& executor_locator);

#endif /* __RIDL_PSDD_SENDER_SVNT_H_IDFCAFCH_INCLUDED__ */

// -*- END -*-
